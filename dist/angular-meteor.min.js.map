{"version":3,"sources":["webpack:///dist/angular-meteor.min.js","webpack:///webpack/bootstrap b5f5480244b0a53ac05c","webpack:///./src/angular-meteor.js","webpack:///./src/lib/get-updates.js","webpack:///./src/lib/diff-array.js","webpack:///./src/modules/angular-meteor-settings.js","webpack:///./src/modules/angular-meteor-ironrouter.js","webpack:///./src/modules/angular-meteor-utils.js","webpack:///./src/modules/angular-meteor-subscribe.js","webpack:///./src/modules/angular-meteor-collection.js","webpack:///./src/modules/angular-meteor-object.js","webpack:///./src/modules/angular-meteor-user.js","webpack:///./src/modules/angular-meteor-methods.js","webpack:///./src/modules/angular-meteor-session.js","webpack:///./src/modules/angular-meteor-camera.js","webpack:///./src/modules/angular-meteor-stopper.js","webpack:///./src/modules/utils.js","webpack:///./src/modules/mixer.js","webpack:///./src/modules/scope.js","webpack:///./src/modules/core.js","webpack:///./src/modules/view-model.js","webpack:///./src/modules/reactive.js","webpack:///./src/modules/templates.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Object","defineProperty","value","name","undefined","_utils","_mixer","_scope","_core","_viewModel","_reactive","_templates","angular","run","Mixer","Core","ViewModel","Reactive","$Mixer","$$Core","$$ViewModel","$$Reactive","mixin","service","$meteorCollection","$meteorCollectionFS","$meteorObject","$meteorMethods","$meteorSession","$meteorSubscribe","$meteorUtils","$meteorCamera","$meteorUser","_this","this","collection","collectionFS","object","subscribe","session","autorun","getCollectionByName","getPicture","forEach","method","utils","rip","obj","level","_","reduce","clone","v","k","isObject","toPaths","keys","getKeyPaths","values","getDeepValues","map","isEmpty","isArray","subKey","flatten","arr","push","setFilled","assert","result","msg","throwErr","Error","getDifference","src","dst","isShallow","compare","srcKeys","dstKeys","chain","concat","uniq","without","diff","srcValue","dstValue","isDate","getTime","valueDiff","getUpdates","paths","set","createSet","unset","createUnset","pull","createPull","updates","undefinedKeys","getUndefinedKeys","omit","pick","arrKeyPaths","split","match","compact","filter","isUndefined","_module","factory","diffArray","lastSeqArray","seqArray","callbacks","preventNestedDiff","diffFn","Package","minimongo","LocalCollection","_diffQueryOrderedChanges","DiffSequence","diffQueryOrderedChanges","oldObjIds","newObjIds","posOld","posNew","posCur","lengthCur","length","each","doc","i","_id","idStringify","addedBefore","before","position","pos","addedAt","movedBefore","prevPosition","movedTo","removed","removedAt","idString","has","idParse","newItem","oldItem","changedAt","_idStringify","MongoID","_idParse","shallow","deepCopyChanges","setDiff","$set","deepKey","setDeep","deepCopyRemovals","unsetDiff","$unset","unsetDeep","getChanges","newCollection","oldCollection","diffMethod","changes","added","changed","item","index","selector","modifier","fromIndex","toIndex","initialKeys","initial","lastKey","last","subObj","nextKey","isNumStr","parseInt","isHash","deepObj","getDeep","splice","getPrototypeOf","prototype","str","constant","suppressWarnings","$compile","$document","$rootScope","Router","isLoaded","onAfterAction","req","res","next","Tracker","afterFlush","$$phase","$apply","_typeof","Symbol","iterator","constructor","angularMeteorUtils","$q","$timeout","$angularMeteorSettings","self","scope","fn","console","warn","comp","firstRun","noop","$on","stop","stripDollarPrefixedKeys","data","Date","File","EJSON","toJSONValue","$type","FS","out","charAt","fulfill","deferred","boundError","boundResult","err","reject","resolve","promissor","defer","args","toArray","arguments","apply","promise","promiseAll","promises","allPromise","all","string","Mongo","Collection","get","findIndexById","foundDoc","find","colDoc","equals","indexOf","$meteorAutorun","angularMeteorSubscribe","_subscribe","subscription","lastArg","isFunction","onStop","_onStop","pop","onReady","$$state","status","Array","slice","Meteor","angularMeteorCollection","AngularMeteorCollection","curDefFunc","diffArrayFunc","autoClientSave","_serverBackup","_diffArrayFunc","_hObserve","_hNewCurAutorun","_hDataAutorun","isDefined","$$collection","cursor","extend","_startCurAutorun","onInvalidate","_stopCursor","_setAutoClientSave","_updateCursor","save","docs","useUnsetModifier","_upsertDoc","createFulfill","partial","docId","isExist","findOne","update","action","insert","_updateDiff","callback","setters","$pull","prop","puller","_updateParallel","done","after","affectedDocsNum","remove","keyOrDocs","keyOrDoc","pluck","check","Match","OneOf","String","ObjectID","key","_removeDoc","_stopObserving","observe","atIndex","_setServerUpdateMode","oldDoc","removedIndex","fetch","_serverMode","_unsetServerUpdateMode","_hUnsetTimeout","_unsetAutoClientSave","cancel","_saveChanges","_hRegAutoBind","$watch","nItems","oItems","addedDocs","reverse","descriptor","removedDocs","reactiveFunc","TypeError","bind","$meteorStopper","scopeProto","angularMeteorObject","AngularMeteorObject","options","helpers","_helpers","create","collectionExtension","$$options","$$id","_getId","$$internalProps","getRawObject","copy","custom","mods","when","reset","keepClientProps","clientProps","docKeys","docExtension","intersection","serverProps","removedKeys","difference","unregisterAutoDestroy","unregisterAutoBind","autorunComputation","fields","reactive","transform","isString","auto","_auto","_setAutos","angularMeteorUser","pack","Accounts","waitForUser","loggingIn","user","requireUser","requireValidUser","validatorFn","then","valid","loginWithPassword","createUser","changePassword","forgotPassword","resetPassword","verifyEmail","logout","logoutOtherClients","loginWithFacebook","loginWithTwitter","loginWithGoogle","loginWithGithub","loginWithMeteorDeveloperAccount","loginWithMeetup","loginWithWeibo","ScopeProto","currentUser","angularMeteorMethods","angularMeteorSession","$parse","model","getter","setter","assign","Session","angularMeteorCamera","MeteorCamera","angularMeteorStopper","$meteorEntity","meteorEntity","$$scope","bindFn","context","tap","_len","_key","bindObj","bound","isCursor","Cursor","isScope","isViewModel","$$dependencies","areSiblings","obj1","obj2","_toConsumableArray","arr2","from","caller","_mixins","_autoExtend","_autoConstruct","union","_extend","_construct","_mixout","_ref","_$defaults","defaults","pattern","mixins","boundMixin","methodName","methodHandler","methodContext","recentCaller","_len2","_key2","configurable","enumerable","Scope","$new","$$utils","$bindToContext","computation","$$autoStop","subName","cb","_Meteor","ready","subscriptionId","callMethod","_Meteor2","applyMethod","_Meteor3","stoppable","$$throttledDigest","isDigestable","$$destroyed","$root","$digest","$$defer","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","writable","protoProps","staticProps","viewModel","vm","_attached","_vm","Dependency","$$setFnHelper","getReactively","isDeep","isBoolean","$$reactivateEntity","getCollectionReactively","$watchCollection","watcher","watcherArgs","$$watchEntity","depend","_this2","getVal","initialVal","val","oldVal","hasChanged","$$changed","_this3","nonreactive","observation","$$handleCursor","$$handleNonCursor","$$setValHelper","_this4","watch","newVal","_this5","jsondiffpatch","patch","$$depend","e"],"mappings":"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","file":"dist/angular-meteor.min.js","sourcesContent":["/*! angular-meteor v1.3.7 */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.name = undefined;\n\t\n\t__webpack_require__(1);\n\t\n\t__webpack_require__(2);\n\t\n\t__webpack_require__(3);\n\t\n\t__webpack_require__(4);\n\t\n\t__webpack_require__(5);\n\t\n\t__webpack_require__(6);\n\t\n\t__webpack_require__(7);\n\t\n\t__webpack_require__(8);\n\t\n\t__webpack_require__(9);\n\t\n\t__webpack_require__(10);\n\t\n\t__webpack_require__(11);\n\t\n\t__webpack_require__(12);\n\t\n\t__webpack_require__(13);\n\t\n\tvar _utils = __webpack_require__(14);\n\t\n\tvar _mixer = __webpack_require__(15);\n\t\n\tvar _scope = __webpack_require__(16);\n\t\n\tvar _core = __webpack_require__(17);\n\t\n\tvar _viewModel = __webpack_require__(18);\n\t\n\tvar _reactive = __webpack_require__(19);\n\t\n\tvar _templates = __webpack_require__(20);\n\t\n\t// legacy\n\t// lib\n\tvar name = exports.name = 'angular-meteor';\n\t\n\t// new\n\t\n\t\n\tangular.module(name, [\n\t// new\n\t_utils.name, _mixer.name, _scope.name, _core.name, _viewModel.name, _reactive.name, _templates.name,\n\t\n\t// legacy\n\t'angular-meteor.ironrouter', 'angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'angular-meteor.object', 'angular-meteor.user', 'angular-meteor.methods', 'angular-meteor.session', 'angular-meteor.camera']).run([_mixer.Mixer, _core.Core, _viewModel.ViewModel, _reactive.Reactive, function ($Mixer, $$Core, $$ViewModel, $$Reactive) {\n\t  // Load all mixins\n\t  $Mixer.mixin($$Core).mixin($$ViewModel).mixin($$Reactive);\n\t}])\n\t\n\t// legacy\n\t// Putting all services under $meteor service for syntactic sugar\n\t.service('$meteor', ['$meteorCollection', '$meteorCollectionFS', '$meteorObject', '$meteorMethods', '$meteorSession', '$meteorSubscribe', '$meteorUtils', '$meteorCamera', '$meteorUser', function ($meteorCollection, $meteorCollectionFS, $meteorObject, $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils, $meteorCamera, $meteorUser) {\n\t  var _this = this;\n\t\n\t  this.collection = $meteorCollection;\n\t  this.collectionFS = $meteorCollectionFS;\n\t  this.object = $meteorObject;\n\t  this.subscribe = $meteorSubscribe.subscribe;\n\t  this.call = $meteorMethods.call;\n\t  this.session = $meteorSession;\n\t  this.autorun = $meteorUtils.autorun;\n\t  this.getCollectionByName = $meteorUtils.getCollectionByName;\n\t  this.getPicture = $meteorCamera.getPicture;\n\t\n\t  // $meteorUser\n\t  ['loginWithPassword', 'requireUser', 'requireValidUser', 'waitForUser', 'createUser', 'changePassword', 'forgotPassword', 'resetPassword', 'verifyEmail', 'loginWithMeteorDeveloperAccount', 'loginWithFacebook', 'loginWithGithub', 'loginWithGoogle', 'loginWithMeetup', 'loginWithTwitter', 'loginWithWeibo', 'logout', 'logoutOtherClients'].forEach(function (method) {\n\t    _this[method] = $meteorUser[method];\n\t  });\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _\n\t */\n\t\n\t'use strict';\n\t\n\t// https://github.com/DAB0mB/get-updates\n\t\n\t(function () {\n\t  var module = angular.module('getUpdates', []);\n\t\n\t  var utils = function () {\n\t    var rip = function rip(obj, level) {\n\t      if (level < 1) return {};\n\t\n\t      return _.reduce(obj, function (clone, v, k) {\n\t        v = _.isObject(v) ? rip(v, --level) : v;\n\t        clone[k] = v;\n\t        return clone;\n\t      }, {});\n\t    };\n\t\n\t    var toPaths = function toPaths(obj) {\n\t      var keys = getKeyPaths(obj);\n\t      var values = getDeepValues(obj);\n\t      return _.object(keys, values);\n\t    };\n\t\n\t    var getKeyPaths = function getKeyPaths(obj) {\n\t      var keys = _.keys(obj).map(function (k) {\n\t        var v = obj[k];\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\t\n\t        return getKeyPaths(v).map(function (subKey) {\n\t          return k + '.' + subKey;\n\t        });\n\t      });\n\t\n\t      return _.flatten(keys);\n\t    };\n\t\n\t    var getDeepValues = function getDeepValues(obj, arr) {\n\t      arr = arr || [];\n\t\n\t      _.values(obj).forEach(function (v) {\n\t        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) arr.push(v);else getDeepValues(v, arr);\n\t      });\n\t\n\t      return arr;\n\t    };\n\t\n\t    var flatten = function flatten(arr) {\n\t      return arr.reduce(function (flattened, v, i) {\n\t        if (_.isArray(v) && !_.isEmpty(v)) flattened.push.apply(flattened, flatten(v));else flattened.push(v);\n\t\n\t        return flattened;\n\t      }, []);\n\t    };\n\t\n\t    var setFilled = function setFilled(obj, k, v) {\n\t      if (!_.isEmpty(v)) obj[k] = v;\n\t    };\n\t\n\t    var assert = function assert(result, msg) {\n\t      if (!result) throwErr(msg);\n\t    };\n\t\n\t    var throwErr = function throwErr(msg) {\n\t      throw Error('get-updates error - ' + msg);\n\t    };\n\t\n\t    return {\n\t      rip: rip,\n\t      toPaths: toPaths,\n\t      getKeyPaths: getKeyPaths,\n\t      getDeepValues: getDeepValues,\n\t      setFilled: setFilled,\n\t      assert: assert,\n\t      throwErr: throwErr\n\t    };\n\t  }();\n\t\n\t  var getDifference = function () {\n\t    var getDifference = function getDifference(src, dst, isShallow) {\n\t      var level;\n\t\n\t      if (isShallow > 1) level = isShallow;else if (isShallow) level = 1;\n\t\n\t      if (level) {\n\t        src = utils.rip(src, level);\n\t        dst = utils.rip(dst, level);\n\t      }\n\t\n\t      return compare(src, dst);\n\t    };\n\t\n\t    var compare = function compare(src, dst) {\n\t      var srcKeys = _.keys(src);\n\t      var dstKeys = _.keys(dst);\n\t\n\t      var keys = _.chain([]).concat(srcKeys).concat(dstKeys).uniq().without('$$hashKey').value();\n\t\n\t      return keys.reduce(function (diff, k) {\n\t        var srcValue = src[k];\n\t        var dstValue = dst[k];\n\t\n\t        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n\t          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n\t        }\n\t\n\t        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n\t          var valueDiff = getDifference(srcValue, dstValue);\n\t          utils.setFilled(diff, k, valueDiff);\n\t        } else if (srcValue !== dstValue) {\n\t          diff[k] = dstValue;\n\t        }\n\t\n\t        return diff;\n\t      }, {});\n\t    };\n\t\n\t    return getDifference;\n\t  }();\n\t\n\t  var getUpdates = function () {\n\t    var getUpdates = function getUpdates(src, dst, isShallow) {\n\t      utils.assert(_.isObject(src), 'first argument must be an object');\n\t      utils.assert(_.isObject(dst), 'second argument must be an object');\n\t\n\t      var diff = getDifference(src, dst, isShallow);\n\t      var paths = utils.toPaths(diff);\n\t\n\t      var set = createSet(paths);\n\t      var unset = createUnset(paths);\n\t      var pull = createPull(unset);\n\t\n\t      var updates = {};\n\t      utils.setFilled(updates, '$set', set);\n\t      utils.setFilled(updates, '$unset', unset);\n\t      utils.setFilled(updates, '$pull', pull);\n\t\n\t      return updates;\n\t    };\n\t\n\t    var createSet = function createSet(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      return _.omit(paths, undefinedKeys);\n\t    };\n\t\n\t    var createUnset = function createUnset(paths) {\n\t      var undefinedKeys = getUndefinedKeys(paths);\n\t      var unset = _.pick(paths, undefinedKeys);\n\t\n\t      return _.reduce(unset, function (result, v, k) {\n\t        result[k] = true;\n\t        return result;\n\t      }, {});\n\t    };\n\t\n\t    var createPull = function createPull(unset) {\n\t      var arrKeyPaths = _.keys(unset).map(function (k) {\n\t        var split = k.match(/(.*)\\.\\d+$/);\n\t        return split && split[1];\n\t      });\n\t\n\t      return _.compact(arrKeyPaths).reduce(function (pull, k) {\n\t        pull[k] = null;\n\t        return pull;\n\t      }, {});\n\t    };\n\t\n\t    var getUndefinedKeys = function getUndefinedKeys(obj) {\n\t      return _.keys(obj).filter(function (k) {\n\t        var v = obj[k];\n\t        return _.isUndefined(v);\n\t      });\n\t    };\n\t\n\t    return getUpdates;\n\t  }();\n\t\n\t  module.value('getUpdates', getUpdates);\n\t})();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _, Package\n\t */\n\t\n\t'use strict';\n\t\n\tvar _module = angular.module('diffArray', ['getUpdates']);\n\t\n\t_module.factory('diffArray', ['getUpdates', function (getUpdates) {\n\t  var LocalCollection = Package.minimongo.LocalCollection;\n\t  var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n\t  var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\t\n\t  // Calculates the differences between `lastSeqArray` and\n\t  // `seqArray` and calls appropriate functions from `callbacks`.\n\t  // Reuses Minimongo's diff algorithm implementation.\n\t  // XXX Should be replaced with the original diffArray function here:\n\t  // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n\t  // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n\t  function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n\t    preventNestedDiff = !!preventNestedDiff;\n\t\n\t    var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges || Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\t\n\t    var oldObjIds = [];\n\t    var newObjIds = [];\n\t    var posOld = {}; // maps from idStringify'd ids\n\t    var posNew = {}; // ditto\n\t    var posCur = {};\n\t    var lengthCur = lastSeqArray.length;\n\t\n\t    _.each(seqArray, function (doc, i) {\n\t      newObjIds.push({ _id: doc._id });\n\t      posNew[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    _.each(lastSeqArray, function (doc, i) {\n\t      oldObjIds.push({ _id: doc._id });\n\t      posOld[idStringify(doc._id)] = i;\n\t      posCur[idStringify(doc._id)] = i;\n\t    });\n\t\n\t    // Arrays can contain arbitrary objects. We don't diff the\n\t    // objects. Instead we always fire 'changedAt' callback on every\n\t    // object. The consumer of `observe-sequence` should deal with\n\t    // it appropriately.\n\t    diffFn(oldObjIds, newObjIds, {\n\t      addedBefore: function addedBefore(id, doc, before) {\n\t        var position = before ? posCur[idStringify(before)] : lengthCur;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= position) posCur[id]++;\n\t        });\n\t\n\t        lengthCur++;\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.addedAt(id, seqArray[posNew[idStringify(id)]], position, before);\n\t      },\n\t\n\t      movedBefore: function movedBefore(id, before) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t        var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition && pos <= position) posCur[id]--;else if (pos <= prevPosition && pos >= position) posCur[id]++;\n\t        });\n\t\n\t        posCur[idStringify(id)] = position;\n\t\n\t        callbacks.movedTo(id, seqArray[posNew[idStringify(id)]], prevPosition, position, before);\n\t      },\n\t      removed: function removed(id) {\n\t        var prevPosition = posCur[idStringify(id)];\n\t\n\t        _.each(posCur, function (pos, id) {\n\t          if (pos >= prevPosition) posCur[id]--;\n\t        });\n\t\n\t        delete posCur[idStringify(id)];\n\t        lengthCur--;\n\t\n\t        callbacks.removedAt(id, lastSeqArray[posOld[idStringify(id)]], prevPosition);\n\t      }\n\t    });\n\t\n\t    _.each(posNew, function (pos, idString) {\n\t      if (!_.has(posOld, idString)) return;\n\t\n\t      var id = idParse(idString);\n\t      var newItem = seqArray[pos] || {};\n\t      var oldItem = lastSeqArray[posOld[idString]];\n\t      var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\t\n\t      if (!_.isEmpty(updates)) callbacks.changedAt(id, updates, pos, oldItem);\n\t    });\n\t  }\n\t\n\t  diffArray.shallow = function (lastSeqArray, seqArray, callbacks) {\n\t    return diffArray(lastSeqArray, seqArray, callbacks, true);\n\t  };\n\t\n\t  diffArray.deepCopyChanges = function (oldItem, newItem) {\n\t    var setDiff = getUpdates(oldItem, newItem).$set;\n\t\n\t    _.each(setDiff, function (v, deepKey) {\n\t      setDeep(oldItem, deepKey, v);\n\t    });\n\t  };\n\t\n\t  diffArray.deepCopyRemovals = function (oldItem, newItem) {\n\t    var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\t\n\t    _.each(unsetDiff, function (v, deepKey) {\n\t      unsetDeep(oldItem, deepKey);\n\t    });\n\t  };\n\t\n\t  // Finds changes between two collections\n\t  diffArray.getChanges = function (newCollection, oldCollection, diffMethod) {\n\t    var changes = { added: [], removed: [], changed: [] };\n\t\n\t    diffMethod(oldCollection, newCollection, {\n\t      addedAt: function addedAt(id, item, index) {\n\t        changes.added.push({ item: item, index: index });\n\t      },\n\t\n\t      removedAt: function removedAt(id, item, index) {\n\t        changes.removed.push({ item: item, index: index });\n\t      },\n\t\n\t      changedAt: function changedAt(id, updates, index, oldItem) {\n\t        changes.changed.push({ selector: id, modifier: updates });\n\t      },\n\t\n\t      movedTo: function movedTo(id, item, fromIndex, toIndex) {\n\t        // XXX do we need this?\n\t      }\n\t    });\n\t\n\t    return changes;\n\t  };\n\t\n\t  var setDeep = function setDeep(obj, deepKey, v) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t\n\t    initialKeys.reduce(function (subObj, k, i) {\n\t      var nextKey = split[i + 1];\n\t\n\t      if (isNumStr(nextKey)) {\n\t        if (subObj[k] === null) subObj[k] = [];\n\t        if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n\t      } else if (subObj[k] === null || !isHash(subObj[k])) {\n\t        subObj[k] = {};\n\t      }\n\t\n\t      return subObj[k];\n\t    }, obj);\n\t\n\t    var deepObj = getDeep(obj, initialKeys);\n\t    deepObj[lastKey] = v;\n\t    return v;\n\t  };\n\t\n\t  var unsetDeep = function unsetDeep(obj, deepKey) {\n\t    var split = deepKey.split('.');\n\t    var initialKeys = _.initial(split);\n\t    var lastKey = _.last(split);\n\t    var deepObj = getDeep(obj, initialKeys);\n\t\n\t    if (_.isArray(deepObj) && isNumStr(lastKey)) return !!deepObj.splice(lastKey, 1);else return delete deepObj[lastKey];\n\t  };\n\t\n\t  var getDeep = function getDeep(obj, keys) {\n\t    return keys.reduce(function (subObj, k) {\n\t      return subObj[k];\n\t    }, obj);\n\t  };\n\t\n\t  var isHash = function isHash(obj) {\n\t    return _.isObject(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n\t  };\n\t\n\t  var isNumStr = function isNumStr(str) {\n\t    return str.match(/^\\d+$/);\n\t  };\n\t\n\t  return diffArray;\n\t}]);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.settings', []).constant('$angularMeteorSettings', {\n\t  suppressWarnings: false\n\t});\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tangular.module('angular-meteor.ironrouter', []).run(['$compile', '$document', '$rootScope', function ($compile, $document, $rootScope) {\n\t  var Router = (Package['iron:router'] || {}).Router;\n\t  if (!Router) return;\n\t\n\t  var isLoaded = false;\n\t\n\t  // Recompile after iron:router builds page\n\t  Router.onAfterAction(function (req, res, next) {\n\t    Tracker.afterFlush(function () {\n\t      if (isLoaded) return;\n\t      $compile($document)($rootScope);\n\t      if (!$rootScope.$$phase) $rootScope.$apply();\n\t      isLoaded = true;\n\t    });\n\t  });\n\t}]);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _, Tracker, EJSON, FS, Mongo\n\t */\n\t\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar angularMeteorUtils = angular.module('angular-meteor.utils', ['angular-meteor.settings']);\n\t\n\tangularMeteorUtils.service('$meteorUtils', ['$q', '$timeout', '$angularMeteorSettings', function ($q, $timeout, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this.autorun = function (scope, fn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    // wrapping around Deps.autorun\n\t    var comp = Tracker.autorun(function (c) {\n\t      fn(c);\n\t      // this is run immediately for the first call\n\t      // but after that, we need to $apply to start Angular digest\n\t      if (!c.firstRun) $timeout(angular.noop, 0);\n\t    });\n\t\n\t    // stop autorun when scope is destroyed\n\t    scope.$on('$destroy', function () {\n\t      comp.stop();\n\t    });\n\t\n\t    // return autorun object so that it can be stopped manually\n\t    return comp;\n\t  };\n\t\n\t  // Borrowed from angularFire\n\t  // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n\t  this.stripDollarPrefixedKeys = function (data) {\n\t    if (!_.isObject(data) || data instanceof Date || data instanceof File || EJSON.toJSONValue(data).$type === 'oid' || (typeof FS === 'undefined' ? 'undefined' : _typeof(FS)) === 'object' && data instanceof FS.File) return data;\n\t\n\t    var out = _.isArray(data) ? [] : {};\n\t\n\t    _.each(data, function (v, k) {\n\t      if (typeof k !== 'string' || k.charAt(0) !== '$') out[k] = self.stripDollarPrefixedKeys(v);\n\t    });\n\t\n\t    return out;\n\t  };\n\t\n\t  // Returns a callback which fulfills promise\n\t  this.fulfill = function (deferred, boundError, boundResult) {\n\t    return function (err, result) {\n\t      if (err) deferred.reject(boundError == null ? err : boundError);else if (typeof boundResult == \"function\") deferred.resolve(boundResult == null ? result : boundResult(result));else deferred.resolve(boundResult == null ? result : boundResult);\n\t    };\n\t  };\n\t\n\t  // creates a function which invokes method with the given arguments and returns a promise\n\t  this.promissor = function (obj, method) {\n\t    return function () {\n\t      var deferred = $q.defer();\n\t      var fulfill = self.fulfill(deferred);\n\t      var args = _.toArray(arguments).concat(fulfill);\n\t      obj[method].apply(obj, args);\n\t      return deferred.promise;\n\t    };\n\t  };\n\t\n\t  // creates a $q.all() promise and call digestion loop on fulfillment\n\t  this.promiseAll = function (promises) {\n\t    var allPromise = $q.all(promises);\n\t\n\t    allPromise.finally(function () {\n\t      // calls digestion loop with no conflicts\n\t      $timeout(angular.noop);\n\t    });\n\t\n\t    return allPromise;\n\t  };\n\t\n\t  this.getCollectionByName = function (string) {\n\t    return Mongo.Collection.get(string);\n\t  };\n\t\n\t  this.findIndexById = function (collection, doc) {\n\t    var foundDoc = _.find(collection, function (colDoc) {\n\t      // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n\t      return EJSON.equals(colDoc._id, doc._id);\n\t    });\n\t\n\t    return _.indexOf(collection, foundDoc);\n\t  };\n\t}]);\n\t\n\tangularMeteorUtils.run(['$rootScope', '$meteorUtils', function ($rootScope, $meteorUtils) {\n\t  Object.getPrototypeOf($rootScope).$meteorAutorun = function (fn) {\n\t    return $meteorUtils.autorun(this, fn);\n\t  };\n\t}]);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Meteor\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', ['angular-meteor.settings']);\n\t\n\tangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings', function ($q, $angularMeteorSettings) {\n\t\n\t  var self = this;\n\t\n\t  this._subscribe = function (scope, deferred, args) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var subscription = null;\n\t    var lastArg = args[args.length - 1];\n\t\n\t    // User supplied onStop callback\n\t    // save it for later use and remove\n\t    // from subscription arguments\n\t    if (angular.isObject(lastArg) && angular.isFunction(lastArg.onStop)) {\n\t      var _onStop = lastArg.onStop;\n\t\n\t      args.pop();\n\t    }\n\t\n\t    args.push({\n\t      onReady: function onReady() {\n\t        deferred.resolve(subscription);\n\t      },\n\t      onStop: function onStop(err) {\n\t        if (!deferred.promise.$$state.status) {\n\t          if (err) deferred.reject(err);else deferred.reject(new Meteor.Error(\"Subscription Stopped\", \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n\t        } else if (_onStop)\n\t          // After promise was resolved or rejected\n\t          // call user supplied onStop callback.\n\t          _onStop.apply(this, Array.prototype.slice.call(arguments));\n\t      }\n\t    });\n\t\n\t    subscription = Meteor.subscribe.apply(scope, args);\n\t\n\t    return subscription;\n\t  };\n\t\n\t  this.subscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var subscription = null;\n\t\n\t    self._subscribe(this, deferred, args);\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\t\n\tangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe', function ($rootScope, $q, $meteorSubscribe) {\n\t  Object.getPrototypeOf($rootScope).$meteorSubscribe = function () {\n\t    var deferred = $q.defer();\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\t\n\t    this.$on('$destroy', function () {\n\t      subscription.stop();\n\t    });\n\t\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _, Tracker, check, Match, Mongo\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCollection = angular.module('angular-meteor.collection', ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray', 'angular-meteor.settings']);\n\t\n\t// The reason angular meteor collection is a factory function and not something\n\t// that inherit from array comes from here:\n\t// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n\t// We went with the direct extensions approach.\n\tangularMeteorCollection.factory('AngularMeteorCollection', ['$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\t\n\t  function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var data = [];\n\t    // Server backup data to evaluate what changes come from client\n\t    // after each server update.\n\t    data._serverBackup = [];\n\t    // Array differ function.\n\t    data._diffArrayFunc = diffArrayFunc;\n\t    // Handler of the cursor observer.\n\t    data._hObserve = null;\n\t    // On new cursor autorun handler\n\t    // (autorun for reactive variables).\n\t    data._hNewCurAutorun = null;\n\t    // On new data autorun handler\n\t    // (autorun for cursor.fetch).\n\t    data._hDataAutorun = null;\n\t\n\t    if (angular.isDefined(collection)) {\n\t      data.$$collection = collection;\n\t    } else {\n\t      var cursor = curDefFunc();\n\t      data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n\t    }\n\t\n\t    _.extend(data, AngularMeteorCollection);\n\t    data._startCurAutorun(curDefFunc, autoClientSave);\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorCollection._startCurAutorun = function (curDefFunc, autoClientSave) {\n\t    var self = this;\n\t\n\t    self._hNewCurAutorun = Tracker.autorun(function () {\n\t      // When the reactive func gets recomputated we need to stop any previous\n\t      // observeChanges.\n\t      Tracker.onInvalidate(function () {\n\t        self._stopCursor();\n\t      });\n\t\n\t      if (autoClientSave) self._setAutoClientSave();\n\t      self._updateCursor(curDefFunc(), autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorCollection.save = function (docs, useUnsetModifier) {\n\t    // save whole collection\n\t    if (!docs) docs = this;\n\t    // save single doc\n\t    docs = [].concat(docs);\n\t\n\t    var promises = docs.map(function (doc) {\n\t      return this._upsertDoc(doc, useUnsetModifier);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._upsertDoc = function (doc, useUnsetModifier) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t\n\t    // delete $$hashkey\n\t    doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n\t    var docId = doc._id;\n\t    var isExist = collection.findOne(docId);\n\t\n\t    // update\n\t    if (isExist) {\n\t      // Deletes _id property (from the copy) so that\n\t      // it can be $set using update.\n\t      delete doc._id;\n\t      var modifier = useUnsetModifier ? { $unset: doc } : { $set: doc };\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      collection.update(docId, modifier, createFulfill(function () {\n\t        return { _id: docId, action: 'updated' };\n\t      }));\n\t    }\n\t    // insert\n\t    else {\n\t        collection.insert(doc, createFulfill(function (id) {\n\t          return { _id: id, action: 'inserted' };\n\t        }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  // performs $pull operations parallely.\n\t  // used for handling splice operations returned from getUpdates() to prevent conflicts.\n\t  // see issue: https://github.com/Urigo/angular-meteor/issues/793\n\t  AngularMeteorCollection._updateDiff = function (selector, update, callback) {\n\t    callback = callback || angular.noop;\n\t    var setters = _.omit(update, '$pull');\n\t    var updates = [setters];\n\t\n\t    _.each(update.$pull, function (pull, prop) {\n\t      var puller = {};\n\t      puller[prop] = pull;\n\t      updates.push({ $pull: puller });\n\t    });\n\t\n\t    this._updateParallel(selector, updates, callback);\n\t  };\n\t\n\t  // performs each update operation parallely\n\t  AngularMeteorCollection._updateParallel = function (selector, updates, callback) {\n\t    var self = this;\n\t    var done = _.after(updates.length, callback);\n\t\n\t    var next = function next(err, affectedDocsNum) {\n\t      if (err) return callback(err);\n\t      done(null, affectedDocsNum);\n\t    };\n\t\n\t    _.each(updates, function (update) {\n\t      self.$$collection.update(selector, update, next);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection.remove = function (keyOrDocs) {\n\t    var keys;\n\t\n\t    // remove whole collection\n\t    if (!keyOrDocs) {\n\t      keys = _.pluck(this, '_id');\n\t    }\n\t    // remove docs\n\t    else {\n\t        keyOrDocs = [].concat(keyOrDocs);\n\t\n\t        keys = _.map(keyOrDocs, function (keyOrDoc) {\n\t          return keyOrDoc._id || keyOrDoc;\n\t        });\n\t      }\n\t\n\t    // Checks if all keys are correct.\n\t    check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\t\n\t    var promises = keys.map(function (key) {\n\t      return this._removeDoc(key);\n\t    }, this);\n\t\n\t    return $meteorUtils.promiseAll(promises);\n\t  };\n\t\n\t  AngularMeteorCollection._removeDoc = function (id) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n\t    collection.remove(id, fulfill);\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorCollection._updateCursor = function (cursor, autoClientSave) {\n\t    var self = this;\n\t    // XXX - consider adding an option for a non-orderd result for faster performance\n\t    if (self._hObserve) self._stopObserving();\n\t\n\t    self._hObserve = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        self.splice(atIndex, 0, doc);\n\t        self._serverBackup.splice(atIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        diffArray.deepCopyChanges(self[atIndex], doc);\n\t        diffArray.deepCopyRemovals(self[atIndex], doc);\n\t        self._serverBackup[atIndex] = self[atIndex];\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        self.splice(fromIndex, 1);\n\t        self.splice(toIndex, 0, doc);\n\t        self._serverBackup.splice(fromIndex, 1);\n\t        self._serverBackup.splice(toIndex, 0, doc);\n\t        self._setServerUpdateMode();\n\t      },\n\t\n\t      removedAt: function removedAt(oldDoc) {\n\t        var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\t\n\t        if (removedIndex != -1) {\n\t          self.splice(removedIndex, 1);\n\t          self._serverBackup.splice(removedIndex, 1);\n\t          self._setServerUpdateMode();\n\t        } else {\n\t          // If it's been removed on client then it's already not in collection\n\t          // itself but still is in the _serverBackup.\n\t          removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\t\n\t          if (removedIndex != -1) {\n\t            self._serverBackup.splice(removedIndex, 1);\n\t          }\n\t        }\n\t      }\n\t    });\n\t\n\t    self._hDataAutorun = Tracker.autorun(function () {\n\t      cursor.fetch();\n\t      if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n\t    });\n\t  };\n\t\n\t  AngularMeteorCollection._stopObserving = function () {\n\t    this._hObserve.stop();\n\t    this._hDataAutorun.stop();\n\t    delete this._serverMode;\n\t    delete this._hUnsetTimeout;\n\t  };\n\t\n\t  AngularMeteorCollection._setServerUpdateMode = function (name) {\n\t    this._serverMode = true;\n\t    // To simplify server update logic, we don't follow\n\t    // updates from the client at the same time.\n\t    this._unsetAutoClientSave();\n\t  };\n\t\n\t  // Here we use $timeout to combine multiple updates that go\n\t  // each one after another.\n\t  AngularMeteorCollection._unsetServerUpdateMode = function (autoClientSave) {\n\t    var self = this;\n\t\n\t    if (self._hUnsetTimeout) {\n\t      $timeout.cancel(self._hUnsetTimeout);\n\t      self._hUnsetTimeout = null;\n\t    }\n\t\n\t    self._hUnsetTimeout = $timeout(function () {\n\t      self._serverMode = false;\n\t      // Finds updates that was potentially done from the client side\n\t      // and saves them.\n\t      var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n\t      self._saveChanges(changes);\n\t      // After, continues following client updates.\n\t      if (autoClientSave) self._setAutoClientSave();\n\t    }, 0);\n\t  };\n\t\n\t  AngularMeteorCollection.stop = function () {\n\t    this._stopCursor();\n\t    this._hNewCurAutorun.stop();\n\t  };\n\t\n\t  AngularMeteorCollection._stopCursor = function () {\n\t    this._unsetAutoClientSave();\n\t\n\t    if (this._hObserve) {\n\t      this._hObserve.stop();\n\t      this._hDataAutorun.stop();\n\t    }\n\t\n\t    this.splice(0);\n\t    this._serverBackup.splice(0);\n\t  };\n\t\n\t  AngularMeteorCollection._unsetAutoClientSave = function (name) {\n\t    if (this._hRegAutoBind) {\n\t      this._hRegAutoBind();\n\t      this._hRegAutoBind = null;\n\t    }\n\t  };\n\t\n\t  AngularMeteorCollection._setAutoClientSave = function () {\n\t    var self = this;\n\t\n\t    // Always unsets auto save to keep only one $watch handler.\n\t    self._unsetAutoClientSave();\n\t\n\t    self._hRegAutoBind = $rootScope.$watch(function () {\n\t      return self;\n\t    }, function (nItems, oItems) {\n\t      if (nItems === oItems) return;\n\t\n\t      var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n\t      self._unsetAutoClientSave();\n\t      self._saveChanges(changes);\n\t      self._setAutoClientSave();\n\t    }, true);\n\t  };\n\t\n\t  AngularMeteorCollection._saveChanges = function (changes) {\n\t    var self = this;\n\t\n\t    // Saves added documents\n\t    // Using reversed iteration to prevent indexes from changing during splice\n\t    var addedDocs = changes.added.reverse().map(function (descriptor) {\n\t      self.splice(descriptor.index, 1);\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (addedDocs.length) self.save(addedDocs);\n\t\n\t    // Removes deleted documents\n\t    var removedDocs = changes.removed.map(function (descriptor) {\n\t      return descriptor.item;\n\t    });\n\t\n\t    if (removedDocs.length) self.remove(removedDocs);\n\t\n\t    // Updates changed documents\n\t    changes.changed.forEach(function (descriptor) {\n\t      self._updateDiff(descriptor.selector, descriptor.modifier);\n\t    });\n\t  };\n\t\n\t  return AngularMeteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollectionFS', ['$meteorCollection', 'diffArray', '$angularMeteorSettings', function ($meteorCollection, diffArray, $angularMeteorSettings) {\n\t  function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\t\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n\t  }\n\t\n\t  return $meteorCollectionFS;\n\t}]);\n\t\n\tangularMeteorCollection.factory('$meteorCollection', ['AngularMeteorCollection', '$rootScope', 'diffArray', function (AngularMeteorCollection, $rootScope, diffArray) {\n\t  function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n\t    // Validate parameters\n\t    if (!reactiveFunc) {\n\t      throw new TypeError('The first argument of $meteorCollection is undefined.');\n\t    }\n\t\n\t    if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n\t      throw new TypeError('The first argument of $meteorCollection must be a function or ' + 'a have a find function property.');\n\t    }\n\t\n\t    if (!angular.isFunction(reactiveFunc)) {\n\t      collection = angular.isDefined(collection) ? collection : reactiveFunc;\n\t      reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n\t    }\n\t\n\t    // By default auto save - true.\n\t    autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n\t    diffFn = diffFn || diffArray;\n\t    return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n\t  }\n\t\n\t  return $meteorCollection;\n\t}]);\n\t\n\tangularMeteorCollection.run(['$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper', function ($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n\t  scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n\t}]);\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*global\n\t  angular, _, Mongo\n\t*/\n\t\n\t'use strict';\n\t\n\tvar angularMeteorObject = angular.module('angular-meteor.object', ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray', 'angular-meteor.settings']);\n\t\n\tangularMeteorObject.factory('AngularMeteorObject', ['$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings', function ($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\t\n\t  // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n\t  AngularMeteorObject.$$internalProps = ['$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope', 'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject', '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'];\n\t\n\t  function AngularMeteorObject(collection, selector, options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    // Make data not be an object so we can extend it to preserve\n\t    // Collection Helpers and the like\n\t    var helpers = collection._helpers;\n\t    var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n\t    var doc = collection.findOne(selector, options);\n\t    var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\n\t    _.extend(data, doc);\n\t    _.extend(data, AngularMeteorObject);\n\t    _.extend(data, collectionExtension);\n\t\n\t    // Omit options that may spoil document finding\n\t    data.$$options = _.omit(options, 'skip', 'limit');\n\t    data.$$collection = collection;\n\t    data.$$id = data._getId(selector);\n\t    data._serverBackup = doc || {};\n\t\n\t    return data;\n\t  }\n\t\n\t  AngularMeteorObject.getRawObject = function () {\n\t    return angular.copy(_.omit(this, this.$$internalProps));\n\t  };\n\t\n\t  AngularMeteorObject.subscribe = function () {\n\t    $meteorSubscribe.subscribe.apply(this, arguments);\n\t    return this;\n\t  };\n\t\n\t  AngularMeteorObject.save = function (custom) {\n\t    var deferred = $q.defer();\n\t    var collection = this.$$collection;\n\t    var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\t    var oldDoc = collection.findOne(this.$$id);\n\t    var mods;\n\t\n\t    // update\n\t    if (oldDoc) {\n\t      if (custom) mods = { $set: custom };else {\n\t        mods = getUpdates(oldDoc, this.getRawObject());\n\t        // If there are no updates, there is nothing to do here, returning\n\t        if (_.isEmpty(mods)) {\n\t          return $q.when({ action: 'updated' });\n\t        }\n\t      }\n\t\n\t      // NOTE: do not use #upsert() method, since it does not exist in some collections\n\t      this._updateDiff(mods, createFulfill({ action: 'updated' }));\n\t    }\n\t    // insert\n\t    else {\n\t        if (custom) mods = _.clone(custom);else mods = this.getRawObject();\n\t\n\t        mods._id = mods._id || this.$$id;\n\t        collection.insert(mods, createFulfill({ action: 'inserted' }));\n\t      }\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  AngularMeteorObject._updateDiff = function (update, callback) {\n\t    var selector = this.$$id;\n\t    AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n\t  };\n\t\n\t  AngularMeteorObject.reset = function (keepClientProps) {\n\t    var self = this;\n\t    var options = this.$$options;\n\t    var id = this.$$id;\n\t    var doc = this.$$collection.findOne(id, options);\n\t\n\t    if (doc) {\n\t      // extend SubObject\n\t      var docKeys = _.keys(doc);\n\t      var docExtension = _.pick(doc, docKeys);\n\t      var clientProps;\n\t\n\t      _.extend(self, docExtension);\n\t      _.extend(self._serverBackup, docExtension);\n\t\n\t      if (keepClientProps) {\n\t        clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n\t      } else {\n\t        clientProps = _.keys(self);\n\t      }\n\t\n\t      var serverProps = _.keys(doc);\n\t      var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\t\n\t      removedKeys.forEach(function (prop) {\n\t        delete self[prop];\n\t        delete self._serverBackup[prop];\n\t      });\n\t    } else {\n\t      _.keys(this.getRawObject()).forEach(function (prop) {\n\t        delete self[prop];\n\t      });\n\t\n\t      self._serverBackup = {};\n\t    }\n\t  };\n\t\n\t  AngularMeteorObject.stop = function () {\n\t    if (this.unregisterAutoDestroy) this.unregisterAutoDestroy();\n\t\n\t    if (this.unregisterAutoBind) this.unregisterAutoBind();\n\t\n\t    if (this.autorunComputation && this.autorunComputation.stop) this.autorunComputation.stop();\n\t  };\n\t\n\t  AngularMeteorObject._getId = function (selector) {\n\t    var options = _.extend({}, this.$$options, {\n\t      fields: { _id: 1 },\n\t      reactive: false,\n\t      transform: null\n\t    });\n\t\n\t    var doc = this.$$collection.findOne(selector, options);\n\t\n\t    if (doc) return doc._id;\n\t    if (selector instanceof Mongo.ObjectID) return selector;\n\t    if (_.isString(selector)) return selector;\n\t    return new Mongo.ObjectID();\n\t  };\n\t\n\t  return AngularMeteorObject;\n\t}]);\n\t\n\tangularMeteorObject.factory('$meteorObject', ['$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject', function ($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n\t  function $meteorObject(collection, id, auto, options) {\n\t    // Validate parameters\n\t    if (!collection) {\n\t      throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n\t    }\n\t\n\t    if (!angular.isFunction(collection.findOne)) {\n\t      throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n\t    }\n\t\n\t    var data = new AngularMeteorObject(collection, id, options);\n\t    // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n\t    data._auto = auto !== false;\n\t    _.extend(data, $meteorObject);\n\t    data._setAutos();\n\t    return data;\n\t  }\n\t\n\t  $meteorObject._setAutos = function () {\n\t    var self = this;\n\t\n\t    this.autorunComputation = $meteorUtils.autorun($rootScope, function () {\n\t      self.reset(true);\n\t    });\n\t\n\t    // Deep watches the model and performs autobind\n\t    this.unregisterAutoBind = this._auto && $rootScope.$watch(function () {\n\t      return self.getRawObject();\n\t    }, function (item, oldItem) {\n\t      if (item !== oldItem) self.save();\n\t    }, true);\n\t\n\t    this.unregisterAutoDestroy = $rootScope.$on('$destroy', function () {\n\t      if (self && self.stop) self.pop();\n\t    });\n\t  };\n\t\n\t  return $meteorObject;\n\t}]);\n\t\n\tangularMeteorObject.run(['$rootScope', '$meteorObject', '$meteorStopper', function ($rootScope, $meteorObject, $meteorStopper) {\n\t  var scopeProto = Object.getPrototypeOf($rootScope);\n\t  scopeProto.$meteorObject = $meteorStopper($meteorObject);\n\t}]);\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _, Package, Meteor\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorUser = angular.module('angular-meteor.user', ['angular-meteor.utils', 'angular-meteor.core', 'angular-meteor.settings']);\n\t\n\t// requires package 'accounts-password'\n\tangularMeteorUser.service('$meteorUser', ['$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings', function ($rootScope, $meteorUtils, $q, $angularMeteorSettings) {\n\t\n\t  var pack = Package['accounts-base'];\n\t  if (!pack) return;\n\t\n\t  var self = this;\n\t  var Accounts = pack.Accounts;\n\t\n\t  this.waitForUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) deferred.resolve(Meteor.user());\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireUser = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) {\n\t      console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t    }\n\t\n\t    var deferred = $q.defer();\n\t\n\t    $meteorUtils.autorun($rootScope, function () {\n\t      if (!Meteor.loggingIn()) {\n\t        if (Meteor.user() === null) deferred.reject(\"AUTH_REQUIRED\");else deferred.resolve(Meteor.user());\n\t      }\n\t    }, true);\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t  this.requireValidUser = function (validatorFn) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    return self.requireUser(true).then(function (user) {\n\t      var valid = validatorFn(user);\n\t\n\t      if (valid === true) return user;else if (typeof valid === \"string\") return $q.reject(valid);else return $q.reject(\"FORBIDDEN\");\n\t    });\n\t  };\n\t\n\t  this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n\t  this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n\t  this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n\t  this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n\t  this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n\t  this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n\t  this.logout = $meteorUtils.promissor(Meteor, 'logout');\n\t  this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n\t  this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n\t  this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n\t  this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n\t  this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n\t  this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n\t  this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n\t  this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n\t}]);\n\t\n\tangularMeteorUser.run(['$rootScope', '$angularMeteorSettings', '$$Core', function ($rootScope, $angularMeteorSettings, $$Core) {\n\t\n\t  var ScopeProto = Object.getPrototypeOf($rootScope);\n\t  _.extend(ScopeProto, $$Core);\n\t\n\t  $rootScope.autorun(function () {\n\t    if (!Meteor.user) return;\n\t    $rootScope.currentUser = Meteor.user();\n\t    $rootScope.loggingIn = Meteor.loggingIn();\n\t  });\n\t}]);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, _, Meteor\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\tangularMeteorMethods.service('$meteorMethods', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  this.call = function () {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    var deferred = $q.defer();\n\t    var fulfill = $meteorUtils.fulfill(deferred);\n\t    var args = _.toArray(arguments).concat(fulfill);\n\t    Meteor.call.apply(this, args);\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Session\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\tangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings', function ($meteorUtils, $parse, $angularMeteorSettings) {\n\t  return function (session) {\n\t\n\t    return {\n\t\n\t      bind: function bind(scope, model) {\n\t        if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t        var getter = $parse(model);\n\t        var setter = getter.assign;\n\t        $meteorUtils.autorun(scope, function () {\n\t          setter(scope, Session.get(session));\n\t        });\n\t\n\t        scope.$watch(model, function (newItem, oldItem) {\n\t          Session.set(session, getter(scope));\n\t        }, true);\n\t      }\n\t    };\n\t  };\n\t}]);\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular, Package\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils', 'angular-meteor.settings']);\n\t\n\t// requires package 'mdg:camera'\n\tangularMeteorCamera.service('$meteorCamera', ['$q', '$meteorUtils', '$angularMeteorSettings', function ($q, $meteorUtils, $angularMeteorSettings) {\n\t  if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t  var pack = Package['mdg:camera'];\n\t  if (!pack) return;\n\t\n\t  var MeteorCamera = pack.MeteorCamera;\n\t\n\t  this.getPicture = function (options) {\n\t    if (!$angularMeteorSettings.suppressWarnings) console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\t\n\t    options = options || {};\n\t    var deferred = $q.defer();\n\t    MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n\t    return deferred.promise;\n\t  };\n\t}]);\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/*global\n\t angular\n\t */\n\t\n\t'use strict';\n\t\n\tvar angularMeteorStopper = angular.module('angular-meteor.stopper', ['angular-meteor.subscribe']);\n\t\n\tangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe', function ($q, $meteorSubscribe) {\n\t  function $meteorStopper($meteorEntity) {\n\t    return function () {\n\t      var args = Array.prototype.slice.call(arguments);\n\t      var meteorEntity = $meteorEntity.apply(this, args);\n\t\n\t      angular.extend(meteorEntity, $meteorStopper);\n\t      meteorEntity.$$scope = this;\n\t\n\t      this.$on('$destroy', function () {\n\t        meteorEntity.stop();\n\t        if (meteorEntity.subscription) meteorEntity.subscription.stop();\n\t      });\n\t\n\t      return meteorEntity;\n\t    };\n\t  }\n\t\n\t  $meteorStopper.subscribe = function () {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n\t    return this;\n\t  };\n\t\n\t  return $meteorStopper;\n\t}]);\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = exports.name = 'angular-meteor.utilities';\n\tvar utils = exports.utils = '$$utils';\n\t\n\tangular.module(name, [])\n\t\n\t/*\n\t  A utility service which is provided with general utility functions\n\t */\n\t.service(utils, ['$rootScope', function ($rootScope) {\n\t  var self = this;\n\t\n\t  // Checks if an object is a cursor\n\t  this.isCursor = function (obj) {\n\t    return obj instanceof Meteor.Collection.Cursor;\n\t  };\n\t\n\t  // Cheecks if an object is a scope\n\t  this.isScope = function (obj) {\n\t    return obj instanceof $rootScope.constructor;\n\t  };\n\t\n\t  // Checks if an object is a view model\n\t  this.isViewModel = function (obj) {\n\t    return _.isObject(obj) && obj.$$dependencies;\n\t  };\n\t\n\t  // Checks if two objects are siblings\n\t  this.areSiblings = function (obj1, obj2) {\n\t    return _.isObject(obj1) && _.isObject(obj2) && Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n\t  };\n\t\n\t  // Binds function into a scpecified context. If an object is provided, will bind every\n\t  // value in the object which is a function. If a tap function is provided, it will be\n\t  // called right after the function has been invoked.\n\t  this.bind = function (fn, context, tap) {\n\t    tap = _.isFunction(tap) ? tap : angular.noop;\n\t    if (_.isFunction(fn)) return bindFn(fn, context, tap);\n\t    if (_.isObject(fn)) return bindObj(fn, context, tap);\n\t    return fn;\n\t  };\n\t\n\t  function bindFn(fn, context, tap) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var result = fn.apply(context, args);\n\t      tap.call(context, {\n\t        result: result,\n\t        args: args\n\t      });\n\t      return result;\n\t    };\n\t  }\n\t\n\t  function bindObj(obj, context, tap) {\n\t    return _.keys(obj).reduce(function (bound, k) {\n\t      bound[k] = self.bind(obj[k], context, tap);\n\t      return bound;\n\t    }, {});\n\t  }\n\t}]);\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar name = exports.name = 'angular-meteor.mixer';\n\tvar Mixer = exports.Mixer = '$Mixer';\n\t\n\tangular.module(name, [])\n\t\n\t/*\n\t  A service which lets us apply mixins into Scope.prototype.\n\t  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n\t  and any time a `ChildScope` prototype is created\n\t  it will be extended by the `$Mixer`.\n\t  This concept is good because it keeps our code\n\t  clean and simple, and easy to extend.\n\t  So any time we would like to define a new behaviour to our scope,\n\t  we will just use the `$Mixer` service.\n\t */\n\t.service(Mixer, function () {\n\t  var _this = this;\n\t\n\t  // Used to store method's caller\n\t  var caller = void 0;\n\t\n\t  this._mixins = [];\n\t  // Apply mixins automatically on specified contexts\n\t  this._autoExtend = [];\n\t  this._autoConstruct = [];\n\t\n\t  // Adds a new mixin\n\t  this.mixin = function (mixin) {\n\t    if (!_.isObject(mixin)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    _this._mixins = _.union(_this._mixins, [mixin]);\n\t    // Apply mixins to stored contexts\n\t    _this._autoExtend.forEach(function (context) {\n\t      return _this._extend(context);\n\t    });\n\t    _this._autoConstruct.forEach(function (context) {\n\t      return _this._construct(context);\n\t    });\n\t    return _this;\n\t  };\n\t\n\t  // Removes a mixin. Useful mainly for test purposes\n\t  this._mixout = function (mixin) {\n\t    _this._mixins = _.without(_this._mixins, mixin);\n\t    return _this;\n\t  };\n\t\n\t  // Invoke function mixins with the provided context and arguments\n\t  this._construct = function (context) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    _this._mixins.filter(_.isFunction).forEach(function (mixin) {\n\t      mixin.call.apply(mixin, [context].concat(args));\n\t    });\n\t\n\t    return context;\n\t  };\n\t\n\t  // Extend prototype with the defined mixins\n\t  this._extend = function (obj, options) {\n\t    var _ref;\n\t\n\t    var _$defaults = _.defaults({}, options, {\n\t      pattern: /.*/ });\n\t\n\t    var pattern = _$defaults.pattern;\n\t    var context = _$defaults.context;\n\t    // The patterns of the keys which will be filtered\n\t\n\t\n\t    var mixins = _this._mixins.map(function (mixin) {\n\t      // Filtering the keys by the specified pattern\n\t      var keys = _.keys(mixin).filter(function (k) {\n\t        return k.match(pattern);\n\t      }).filter(function (k) {\n\t        return _.isFunction(mixin[k]);\n\t      });\n\t\n\t      return keys.reduce(function (boundMixin, methodName) {\n\t        var methodHandler = mixin[methodName];\n\t\n\t        // Note that this is not an arrow function so we can conserve the conetxt\n\t        boundMixin[methodName] = function () {\n\t          // Storing original caller so we will know who actually called the\n\t          // method event though it is bound to another context\n\t          var methodContext = context || this;\n\t          var recentCaller = caller;\n\t          caller = this;\n\t\n\t          try {\n\t            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t              args[_key2] = arguments[_key2];\n\t            }\n\t\n\t            return methodHandler.apply(methodContext, args);\n\t          } finally {\n\t            // No matter what happens, restore variable to the previous one\n\t            caller = recentCaller;\n\t          }\n\t        };\n\t\n\t        return boundMixin;\n\t      }, {});\n\t    });\n\t\n\t    return (_ref = _).extend.apply(_ref, [obj].concat(_toConsumableArray(mixins)));\n\t  };\n\t\n\t  // Caller property can not be set\n\t  Object.defineProperty(this, 'caller', {\n\t    configurable: true,\n\t    enumerable: true,\n\t\n\t    get: function get() {\n\t      return caller;\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.name = undefined;\n\t\n\tvar _mixer = __webpack_require__(15);\n\t\n\tvar name = exports.name = 'angular-meteor.scope';\n\t\n\tangular.module(name, [_mixer.name]).run(['$rootScope', _mixer.Mixer, function ($rootScope, $Mixer) {\n\t  var Scope = $rootScope.constructor;\n\t  var $new = $rootScope.$new;\n\t\n\t  // Apply extensions whether a mixin in defined.\n\t  // Note that this way mixins which are initialized later\n\t  // can be applied on rootScope.\n\t  $Mixer._autoExtend.push(Scope.prototype);\n\t  $Mixer._autoConstruct.push($rootScope);\n\t\n\t  Scope.prototype.$new = function () {\n\t    var scope = $new.apply(this, arguments);\n\t    // Apply constructors to newly created scopes\n\t    return $Mixer._construct(scope);\n\t  };\n\t}]);\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Core = exports.name = undefined;\n\t\n\tvar _utils = __webpack_require__(14);\n\t\n\tvar _mixer = __webpack_require__(15);\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tvar name = exports.name = 'angular-meteor.core';\n\tvar Core = exports.Core = '$$Core';\n\t\n\tangular.module(name, [_utils.name, _mixer.name])\n\t\n\t/*\n\t  A mixin which provides us with core Meteor functions.\n\t */\n\t.factory(Core, ['$q', _utils.utils, _mixer.Mixer, function ($q, $$utils, $Mixer) {\n\t  function $$Core() {}\n\t\n\t  // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n\t  $$Core.autorun = function (fn) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    fn = this.$bindToContext($Mixer.caller, fn);\n\t\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 1 must be a function');\n\t    }\n\t    if (!_.isObject(options)) {\n\t      throw Error('argument 2 must be an object');\n\t    }\n\t\n\t    var computation = Tracker.autorun(fn, options);\n\t    this.$$autoStop(computation);\n\t    return computation;\n\t  };\n\t\n\t  // Calls Meteor.subscribe() which will be digested after each invokation\n\t  // and automatically destroyed\n\t  $$Core.subscribe = function (subName, fn, cb) {\n\t    fn = this.$bindToContext($Mixer.caller, fn || angular.noop);\n\t    cb = cb ? this.$bindToContext($Mixer.caller, cb) : angular.noop;\n\t\n\t    if (!_.isString(subName)) {\n\t      throw Error('argument 1 must be a string');\n\t    }\n\t    if (!_.isFunction(fn)) {\n\t      throw Error('argument 2 must be a function');\n\t    }\n\t    if (!_.isFunction(cb) && !_.isObject(cb)) {\n\t      throw Error('argument 3 must be a function or an object');\n\t    }\n\t\n\t    var result = {};\n\t\n\t    var computation = this.autorun(function () {\n\t      var _Meteor;\n\t\n\t      var args = fn();\n\t      if (angular.isUndefined(args)) args = [];\n\t\n\t      if (!_.isArray(args)) {\n\t        throw Error('reactive function\\'s return value must be an array');\n\t      }\n\t\n\t      var subscription = (_Meteor = Meteor).subscribe.apply(_Meteor, [subName].concat(_toConsumableArray(args), [cb]));\n\t      result.ready = subscription.ready.bind(subscription);\n\t      result.subscriptionId = subscription.subscriptionId;\n\t    });\n\t\n\t    // Once the computation has been stopped,\n\t    // any subscriptions made inside will be stopped as well\n\t    result.stop = computation.stop.bind(computation);\n\t    return result;\n\t  };\n\t\n\t  // Calls Meteor.call() wrapped by a digestion cycle\n\t  $$Core.callMethod = function () {\n\t    var _Meteor2;\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor2 = Meteor).call.apply(_Meteor2, args.concat([fn]));\n\t  };\n\t\n\t  // Calls Meteor.apply() wrapped by a digestion cycle\n\t  $$Core.applyMethod = function () {\n\t    var _Meteor3;\n\t\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    var fn = args.pop();\n\t    if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n\t    return (_Meteor3 = Meteor).apply.apply(_Meteor3, args.concat([fn]));\n\t  };\n\t\n\t  $$Core.$$autoStop = function (stoppable) {\n\t    this.$on('$destroy', stoppable.stop.bind(stoppable));\n\t  };\n\t\n\t  // Digests scope only if there is no phase at the moment\n\t  $$Core.$$throttledDigest = function () {\n\t    var isDigestable = !this.$$destroyed && !this.$$phase && !this.$root.$$phase;\n\t\n\t    if (isDigestable) this.$digest();\n\t  };\n\t\n\t  // Creates a promise only that the digestion cycle will be called at its fulfillment\n\t  $$Core.$$defer = function () {\n\t    var deferred = $q.defer();\n\t    // Once promise has been fulfilled, digest\n\t    deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n\t    return deferred;\n\t  };\n\t\n\t  // Binds an object or a function to the provided context and digest it once it is invoked\n\t  $$Core.$bindToContext = function (context, fn) {\n\t    return $$utils.bind(fn, context, this.$$throttledDigest.bind(this));\n\t  };\n\t\n\t  return $$Core;\n\t}]);\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.reactive = exports.ViewModel = exports.name = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(14);\n\t\n\tvar _mixer = __webpack_require__(15);\n\t\n\tvar _core = __webpack_require__(17);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar name = exports.name = 'angular-meteor.view-model';\n\tvar ViewModel = exports.ViewModel = '$$ViewModel';\n\tvar reactive = exports.reactive = '$reactive';\n\t\n\tangular.module(name, [_utils.name, _mixer.name, _core.name])\n\t\n\t/*\n\t  A mixin which lets us bind a view model into a scope.\n\t  Note that only a single view model can be bound,\n\t  otherwise the scope might behave unexpectedly.\n\t  Mainly used to define the controller as the view model,\n\t  and very useful when wanting to use Angular's `controllerAs` syntax.\n\t */\n\t.factory(ViewModel, [_utils.utils, _mixer.Mixer, function ($$utils, $Mixer) {\n\t  function $$ViewModel() {}\n\t\n\t  // Gets an object, wraps it with scope functions and returns it\n\t  $$ViewModel.viewModel = function (vm) {\n\t    if (!_.isObject(vm)) {\n\t      throw Error('argument 1 must be an object');\n\t    }\n\t\n\t    // Extend view model with mixin functions\n\t    $Mixer._extend(vm, {\n\t      pattern: /^(?!\\$\\$).*$/, // Omitting methods which start with a $$ notation\n\t      context: this // Binding methods to scope\n\t    });\n\t\n\t    // Apply mixin constructors on scope with view model\n\t    $Mixer._construct(this, vm);\n\t    return vm;\n\t  };\n\t\n\t  return $$ViewModel;\n\t}])\n\t\n\t/*\n\t  Illustrates the old API where a view model is created using $reactive service\n\t */\n\t.service(reactive, [_utils.utils, function ($$utils) {\n\t  var Reactive = function () {\n\t    function Reactive(vm) {\n\t      var _this = this;\n\t\n\t      _classCallCheck(this, Reactive);\n\t\n\t      if (!_.isObject(vm)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t\n\t      _.defer(function () {\n\t        if (!_this._attached) {\n\t          console.warn('view model was not attached to any scope');\n\t        }\n\t      });\n\t\n\t      this._vm = vm;\n\t    }\n\t\n\t    _createClass(Reactive, [{\n\t      key: 'attach',\n\t      value: function attach(scope) {\n\t        this._attached = true;\n\t\n\t        if (!$$utils.isScope(scope)) {\n\t          throw Error('argument 1 must be a scope');\n\t        }\n\t\n\t        var viewModel = scope.viewModel(this._vm);\n\t\n\t        // Similar to the old/Meteor API\n\t        viewModel.call = viewModel.callMethod;\n\t        viewModel.apply = viewModel.applyMethod;\n\t\n\t        return viewModel;\n\t      }\n\t    }]);\n\t\n\t    return Reactive;\n\t  }();\n\t\n\t  return function (vm) {\n\t    return new Reactive(vm);\n\t  };\n\t}]);\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Reactive = exports.name = undefined;\n\t\n\tvar _utils = __webpack_require__(14);\n\t\n\tvar _mixer = __webpack_require__(15);\n\t\n\tvar _core = __webpack_require__(17);\n\t\n\tvar _viewModel = __webpack_require__(18);\n\t\n\tvar name = exports.name = 'angular-meteor.reactive';\n\tvar Reactive = exports.Reactive = '$$Reactive';\n\t\n\tangular.module(name, [_utils.name, _mixer.name, _core.name, _viewModel.name])\n\t\n\t/*\n\t  A mixin which enhance our reactive abilities by providing methods\n\t  that are capable of updating our scope reactively.\n\t */\n\t.factory(Reactive, ['$parse', _utils.utils, _mixer.Mixer, function ($parse, $$utils, $Mixer) {\n\t  function $$Reactive() {\n\t    var vm = arguments.length <= 0 || arguments[0] === undefined ? this : arguments[0];\n\t\n\t    // Helps us track changes made in the view model\n\t    vm.$$dependencies = {};\n\t  }\n\t\n\t  // Gets an object containing functions and define their results as reactive properties.\n\t  // Once a return value has been changed the property will be reset.\n\t  $$Reactive.helpers = function (vm, props) {\n\t    var _this = this;\n\t\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_.isObject(props)) {\n\t        throw Error('argument 2 must be an object');\n\t      }\n\t    } else {\n\t      props = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_.isObject(props)) {\n\t        throw Error('argument 1 must be an object');\n\t      }\n\t    }\n\t\n\t    _.each(props, function (v, k) {\n\t      if (!_.isFunction(v)) {\n\t        throw Error('helper \\'' + k + '\\' must be a function');\n\t      }\n\t    });\n\t\n\t    _.each(props, function (v, k) {\n\t      if (!vm.$$dependencies[k]) {\n\t        // Registers a new dependency to the specified helper\n\t        vm.$$dependencies[k] = new Tracker.Dependency();\n\t      }\n\t\n\t      _this.$$setFnHelper(vm, k, v);\n\t    });\n\t  };\n\t\n\t  // Gets a model reactively\n\t  $$Reactive.getReactively = function (vm, k, isDeep) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (angular.isUndefined(isDeep)) isDeep = false;\n\t\n\t      if (!_.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t      if (!_.isBoolean(isDeep)) {\n\t        throw Error('argument 3 must be a boolean');\n\t      }\n\t    } else {\n\t      isDeep = angular.isDefined(k) ? k : false;\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t      if (!_.isBoolean(isDeep)) {\n\t        throw Error('argument 2 must be a boolean');\n\t      }\n\t    }\n\t\n\t    return this.$$reactivateEntity(vm, k, this.$watch, isDeep);\n\t  };\n\t\n\t  // Gets a collection reactively\n\t  $$Reactive.getCollectionReactively = function (vm, k) {\n\t    if ($$utils.isViewModel(vm)) {\n\t      if (!_.isString(k)) {\n\t        throw Error('argument 2 must be a string');\n\t      }\n\t    } else {\n\t      k = vm;\n\t      vm = $Mixer.caller;\n\t\n\t      if (!_.isString(k)) {\n\t        throw Error('argument 1 must be a string');\n\t      }\n\t    }\n\t\n\t    return this.$$reactivateEntity(vm, k, this.$watchCollection);\n\t  };\n\t\n\t  // Gets an entity reactively, and once it has been changed the computation will be recomputed\n\t  $$Reactive.$$reactivateEntity = function (vm, k, watcher) {\n\t    if (!vm.$$dependencies[k]) {\n\t      vm.$$dependencies[k] = new Tracker.Dependency();\n\t\n\t      for (var _len = arguments.length, watcherArgs = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n\t        watcherArgs[_key - 3] = arguments[_key];\n\t      }\n\t\n\t      this.$$watchEntity.apply(this, [vm, k, watcher].concat(watcherArgs));\n\t    }\n\t\n\t    vm.$$dependencies[k].depend();\n\t    return $parse(k)(vm);\n\t  };\n\t\n\t  // Watches for changes in the view model, and if so will notify a change\n\t  $$Reactive.$$watchEntity = function (vm, k, watcher) {\n\t    var _this2 = this;\n\t\n\t    // Gets a deep property from the caller\n\t    var getVal = _.partial($parse(k), vm);\n\t    var initialVal = getVal();\n\t\n\t    // Watches for changes in the view model\n\t\n\t    for (var _len2 = arguments.length, watcherArgs = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t      watcherArgs[_key2 - 3] = arguments[_key2];\n\t    }\n\t\n\t    watcher.call.apply(watcher, [this, getVal, function (val, oldVal) {\n\t      var hasChanged = val !== initialVal || val !== oldVal;\n\t\n\t      // Notify if a change has been detected\n\t      if (hasChanged) _this2.$$changed(vm, k);\n\t    }].concat(watcherArgs));\n\t  };\n\t\n\t  // Invokes a function and sets the return value as a property\n\t  $$Reactive.$$setFnHelper = function (vm, k, fn) {\n\t    var _this3 = this;\n\t\n\t    this.autorun(function (computation) {\n\t      // Invokes the reactive functon\n\t      var model = fn.apply(vm);\n\t\n\t      // Ignore notifications made by the following handler\n\t      Tracker.nonreactive(function () {\n\t        // If a cursor, observe its changes and update acoordingly\n\t        if ($$utils.isCursor(model)) {\n\t          (function () {\n\t            var observation = _this3.$$handleCursor(vm, k, model);\n\t\n\t            computation.onInvalidate(function () {\n\t              observation.stop();\n\t              vm[k].splice(0);\n\t            });\n\t          })();\n\t        } else {\n\t          _this3.$$handleNonCursor(vm, k, model);\n\t        }\n\t\n\t        // Notify change and update the view model\n\t        _this3.$$changed(vm, k);\n\t      });\n\t    });\n\t  };\n\t\n\t  // Sets a value helper as a setter and a getter which will notify computations once used\n\t  $$Reactive.$$setValHelper = function (vm, k, v) {\n\t    var _this4 = this;\n\t\n\t    var watch = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];\n\t\n\t    // If set, reactives property\n\t    if (watch) {\n\t      var isDeep = _.isObject(v);\n\t      this.getReactively(vm, k, isDeep);\n\t    }\n\t\n\t    Object.defineProperty(vm, k, {\n\t      configurable: true,\n\t      enumerable: true,\n\t\n\t      get: function get() {\n\t        return v;\n\t      },\n\t      set: function set(newVal) {\n\t        v = newVal;\n\t        _this4.$$changed(vm, k);\n\t      }\n\t    });\n\t  };\n\t\n\t  // Fetching a cursor and updates properties once the result set has been changed\n\t  $$Reactive.$$handleCursor = function (vm, k, cursor) {\n\t    var _this5 = this;\n\t\n\t    // If not defined set it\n\t    if (angular.isUndefined(vm[k])) {\n\t      this.$$setValHelper(vm, k, cursor.fetch(), false);\n\t    }\n\t    // If defined update it\n\t    else {\n\t        var diff = jsondiffpatch.diff(vm[k], cursor.fetch());\n\t        jsondiffpatch.patch(vm[k], diff);\n\t      }\n\t\n\t    // Observe changes made in the result set\n\t    var observation = cursor.observe({\n\t      addedAt: function addedAt(doc, atIndex) {\n\t        if (!observation) return;\n\t        vm[k].splice(atIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      changedAt: function changedAt(doc, oldDoc, atIndex) {\n\t        var diff = jsondiffpatch.diff(vm[k][atIndex], doc);\n\t        jsondiffpatch.patch(vm[k][atIndex], diff);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      movedTo: function movedTo(doc, fromIndex, toIndex) {\n\t        vm[k].splice(fromIndex, 1);\n\t        vm[k].splice(toIndex, 0, doc);\n\t        _this5.$$changed(vm, k);\n\t      },\n\t      removedAt: function removedAt(oldDoc, atIndex) {\n\t        vm[k].splice(atIndex, 1);\n\t        _this5.$$changed(vm, k);\n\t      }\n\t    });\n\t\n\t    return observation;\n\t  };\n\t\n\t  $$Reactive.$$handleNonCursor = function (vm, k, data) {\n\t    var v = vm[k];\n\t\n\t    if (angular.isDefined(v)) {\n\t      delete vm[k];\n\t      v = null;\n\t    }\n\t\n\t    if (angular.isUndefined(v)) {\n\t      this.$$setValHelper(vm, k, data);\n\t    }\n\t    // Update property if the new value is from the same type\n\t    else if ($$utils.areSiblings(v, data)) {\n\t        var diff = jsondiffpatch.diff(v, data);\n\t        jsondiffpatch.patch(v, diff);\n\t        this.$$changed(vm, k);\n\t      } else {\n\t        vm[k] = data;\n\t      }\n\t  };\n\t\n\t  // Notifies dependency in view model\n\t  $$Reactive.$$depend = function (vm, k) {\n\t    vm.$$dependencies[k].depend();\n\t  };\n\t\n\t  // Notifies change in view model\n\t  $$Reactive.$$changed = function (vm, k) {\n\t    this.$$throttledDigest();\n\t    vm.$$dependencies[k].changed();\n\t  };\n\t\n\t  return $$Reactive;\n\t}]);\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar name = exports.name = 'angular-templates';\n\t\n\ttry {\n\t  angular.module(name);\n\t} catch (e) {\n\t  angular.module(name, []);\n\t}\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-meteor.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b5f5480244b0a53ac05c\n **/","// lib\nimport './lib/get-updates';\nimport './lib/diff-array';\n// legacy\nimport './modules/angular-meteor-settings';\nimport './modules/angular-meteor-ironrouter';\nimport './modules/angular-meteor-utils';\nimport './modules/angular-meteor-subscribe';\nimport './modules/angular-meteor-collection';\nimport './modules/angular-meteor-object';\nimport './modules/angular-meteor-user';\nimport './modules/angular-meteor-methods';\nimport './modules/angular-meteor-session';\nimport './modules/angular-meteor-camera';\nimport './modules/angular-meteor-stopper';\n\n// new\nimport { name as utilsName } from './modules/utils';\nimport { name as mixerName, Mixer } from './modules/mixer';\nimport { name as scopeName } from './modules/scope';\nimport { name as coreName, Core } from './modules/core';\nimport { name as viewModelName, ViewModel } from './modules/view-model';\nimport { name as reactiveName, Reactive } from './modules/reactive';\nimport { name as templatesName } from './modules/templates';\n\nexport const name = 'angular-meteor';\n\nangular.module(name, [\n  // new\n  utilsName,\n  mixerName,\n  scopeName,\n  coreName,\n  viewModelName,\n  reactiveName,\n  templatesName,\n\n  // legacy\n  'angular-meteor.ironrouter',\n  'angular-meteor.utils',\n  'angular-meteor.subscribe',\n  'angular-meteor.collection',\n  'angular-meteor.object',\n  'angular-meteor.user',\n  'angular-meteor.methods',\n  'angular-meteor.session',\n  'angular-meteor.camera'\n\n])\n\n.run([\n  Mixer,\n  Core,\n  ViewModel,\n  Reactive,\n\n  function($Mixer, $$Core, $$ViewModel, $$Reactive) {\n    // Load all mixins\n    $Mixer\n      .mixin($$Core)\n      .mixin($$ViewModel)\n      .mixin($$Reactive);\n  }\n])\n\n// legacy\n// Putting all services under $meteor service for syntactic sugar\n.service('$meteor', [\n  '$meteorCollection',\n  '$meteorCollectionFS',\n  '$meteorObject',\n  '$meteorMethods',\n  '$meteorSession',\n  '$meteorSubscribe',\n  '$meteorUtils',\n  '$meteorCamera',\n  '$meteorUser',\n  function($meteorCollection, $meteorCollectionFS, $meteorObject,\n    $meteorMethods, $meteorSession, $meteorSubscribe, $meteorUtils,\n    $meteorCamera, $meteorUser) {\n    this.collection = $meteorCollection;\n    this.collectionFS = $meteorCollectionFS;\n    this.object = $meteorObject;\n    this.subscribe = $meteorSubscribe.subscribe;\n    this.call = $meteorMethods.call;\n    this.session = $meteorSession;\n    this.autorun = $meteorUtils.autorun;\n    this.getCollectionByName = $meteorUtils.getCollectionByName;\n    this.getPicture = $meteorCamera.getPicture;\n\n    // $meteorUser\n    [\n      'loginWithPassword',\n      'requireUser',\n      'requireValidUser',\n      'waitForUser',\n      'createUser',\n      'changePassword',\n      'forgotPassword',\n      'resetPassword',\n      'verifyEmail',\n      'loginWithMeteorDeveloperAccount',\n      'loginWithFacebook',\n      'loginWithGithub',\n      'loginWithGoogle',\n      'loginWithMeetup',\n      'loginWithTwitter',\n      'loginWithWeibo',\n      'logout',\n      'logoutOtherClients'\n    ].forEach((method) => {\n      this[method] = $meteorUser[method];\n    });\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/angular-meteor.js\n **/","/*global\n angular, _\n */\n\n'use strict';\n\n// https://github.com/DAB0mB/get-updates\n(function() {\n  var module = angular.module('getUpdates', []);\n\n  var utils = (function() {\n    var rip = function(obj, level) {\n      if (level < 1) return {};\n\n      return _.reduce(obj, function(clone, v, k) {\n        v = _.isObject(v) ? rip(v, --level) : v;\n        clone[k] = v;\n        return clone;\n      }, {});\n    };\n\n    var toPaths = function(obj) {\n      var keys = getKeyPaths(obj);\n      var values = getDeepValues(obj);\n      return _.object(keys, values);\n    };\n\n    var getKeyPaths = function(obj) {\n      var keys = _.keys(obj).map(function(k) {\n        var v = obj[k];\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v)) return k;\n\n        return getKeyPaths(v).map(function(subKey) {\n          return k + '.' + subKey;\n        });\n      });\n\n      return _.flatten(keys);\n    };\n\n    var getDeepValues = function(obj,arr) {\n      arr = arr || [];\n\n      _.values(obj).forEach(function(v) {\n        if (!_.isObject(v) || _.isEmpty(v) || _.isArray(v))\n          arr.push(v);\n        else\n          getDeepValues(v, arr);\n      });\n\n      return arr;\n    };\n\n    var flatten = function(arr) {\n      return arr.reduce(function(flattened, v, i) {\n        if (_.isArray(v) && !_.isEmpty(v))\n          flattened.push.apply(flattened, flatten(v));\n        else\n          flattened.push(v);\n\n        return flattened;\n      }, []);\n    };\n\n    var setFilled = function(obj, k, v) {\n      if (!_.isEmpty(v)) obj[k] = v;\n    };\n\n    var assert = function(result, msg) {\n      if (!result) throwErr(msg);\n    };\n\n    var throwErr = function(msg) {\n      throw Error('get-updates error - ' + msg);\n    };\n\n    return {\n      rip: rip,\n      toPaths: toPaths,\n      getKeyPaths: getKeyPaths,\n      getDeepValues: getDeepValues,\n      setFilled: setFilled,\n      assert: assert,\n      throwErr: throwErr\n    };\n  })();\n\n  var getDifference = (function() {\n    var getDifference = function(src, dst, isShallow) {\n      var level;\n\n      if (isShallow > 1)\n        level = isShallow;\n      else if (isShallow)\n        level = 1;\n\n      if (level) {\n        src = utils.rip(src, level);\n        dst = utils.rip(dst, level);\n      }\n\n      return compare(src, dst);\n    };\n\n    var compare = function(src, dst) {\n      var srcKeys = _.keys(src);\n      var dstKeys = _.keys(dst);\n\n      var keys = _.chain([])\n        .concat(srcKeys)\n        .concat(dstKeys)\n        .uniq()\n        .without('$$hashKey')\n        .value();\n\n      return keys.reduce(function(diff, k) {\n        var srcValue = src[k];\n        var dstValue = dst[k];\n\n        if (_.isDate(srcValue) && _.isDate(dstValue)) {\n          if (srcValue.getTime() != dstValue.getTime()) diff[k] = dstValue;\n        }\n\n        if (_.isObject(srcValue) && _.isObject(dstValue)) {\n          var valueDiff = getDifference(srcValue, dstValue);\n          utils.setFilled(diff, k, valueDiff);\n        }\n\n        else if (srcValue !== dstValue) {\n          diff[k] = dstValue;\n        }\n\n        return diff;\n      }, {});\n    };\n\n    return getDifference;\n  })();\n\n  var getUpdates = (function() {\n    var getUpdates = function(src, dst, isShallow) {\n      utils.assert(_.isObject(src), 'first argument must be an object');\n      utils.assert(_.isObject(dst), 'second argument must be an object');\n\n      var diff = getDifference(src, dst, isShallow);\n      var paths = utils.toPaths(diff);\n\n      var set = createSet(paths);\n      var unset = createUnset(paths);\n      var pull = createPull(unset);\n\n      var updates = {};\n      utils.setFilled(updates, '$set', set);\n      utils.setFilled(updates, '$unset', unset);\n      utils.setFilled(updates, '$pull', pull);\n\n      return updates;\n    };\n\n    var createSet = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      return _.omit(paths, undefinedKeys);\n    };\n\n    var createUnset = function(paths) {\n      var undefinedKeys = getUndefinedKeys(paths);\n      var unset = _.pick(paths, undefinedKeys);\n\n      return _.reduce(unset, function(result, v, k) {\n        result[k] = true;\n        return result;\n      }, {});\n    };\n\n    var createPull = function(unset) {\n      var arrKeyPaths = _.keys(unset).map(function(k) {\n        var split = k.match(/(.*)\\.\\d+$/);\n        return split && split[1];\n      });\n\n      return _.compact(arrKeyPaths).reduce(function(pull, k) {\n        pull[k] = null;\n        return pull;\n      }, {});\n    };\n\n    var getUndefinedKeys = function(obj) {\n      return _.keys(obj).filter(function (k) {\n        var v = obj[k];\n        return _.isUndefined(v);\n      });\n    };\n\n    return getUpdates;\n  })();\n\n  module.value('getUpdates', getUpdates);\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/get-updates.js\n **/","/*global\n angular, _, Package\n */\n\n'use strict';\n\nvar _module = angular.module('diffArray', ['getUpdates']);\n\n_module.factory('diffArray', ['getUpdates',\n  function(getUpdates) {\n    var LocalCollection = Package.minimongo.LocalCollection;\n    var idStringify = LocalCollection._idStringify || Package['mongo-id'].MongoID.idStringify;\n    var idParse = LocalCollection._idParse || Package['mongo-id'].MongoID.idParse;\n\n    // Calculates the differences between `lastSeqArray` and\n    // `seqArray` and calls appropriate functions from `callbacks`.\n    // Reuses Minimongo's diff algorithm implementation.\n    // XXX Should be replaced with the original diffArray function here:\n    // https://github.com/meteor/meteor/blob/devel/packages/observe-sequence/observe_sequence.js#L152\n    // When it will become nested as well, tracking here: https://github.com/meteor/meteor/issues/3764\n    function diffArray(lastSeqArray, seqArray, callbacks, preventNestedDiff) {\n      preventNestedDiff = !!preventNestedDiff;\n\n      var diffFn = Package.minimongo.LocalCollection._diffQueryOrderedChanges ||\n        Package['diff-sequence'].DiffSequence.diffQueryOrderedChanges;\n\n      var oldObjIds = [];\n      var newObjIds = [];\n      var posOld = {}; // maps from idStringify'd ids\n      var posNew = {}; // ditto\n      var posCur = {};\n      var lengthCur = lastSeqArray.length;\n\n      _.each(seqArray, function (doc, i) {\n        newObjIds.push({_id: doc._id});\n        posNew[idStringify(doc._id)] = i;\n      });\n\n      _.each(lastSeqArray, function (doc, i) {\n        oldObjIds.push({_id: doc._id});\n        posOld[idStringify(doc._id)] = i;\n        posCur[idStringify(doc._id)] = i;\n      });\n\n      // Arrays can contain arbitrary objects. We don't diff the\n      // objects. Instead we always fire 'changedAt' callback on every\n      // object. The consumer of `observe-sequence` should deal with\n      // it appropriately.\n      diffFn(oldObjIds, newObjIds, {\n        addedBefore: function (id, doc, before) {\n          var position = before ? posCur[idStringify(before)] : lengthCur;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= position) posCur[id]++;\n          });\n\n          lengthCur++;\n          posCur[idStringify(id)] = position;\n\n          callbacks.addedAt(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            position,\n            before\n          );\n        },\n\n        movedBefore: function (id, before) {\n          var prevPosition = posCur[idStringify(id)];\n          var position = before ? posCur[idStringify(before)] : lengthCur - 1;\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition && pos <= position)\n              posCur[id]--;\n            else if (pos <= prevPosition && pos >= position)\n              posCur[id]++;\n          });\n\n          posCur[idStringify(id)] = position;\n\n          callbacks.movedTo(\n            id,\n            seqArray[posNew[idStringify(id)]],\n            prevPosition,\n            position,\n            before\n          );\n        },\n        removed: function (id) {\n          var prevPosition = posCur[idStringify(id)];\n\n          _.each(posCur, function (pos, id) {\n            if (pos >= prevPosition) posCur[id]--;\n          });\n\n          delete posCur[idStringify(id)];\n          lengthCur--;\n\n          callbacks.removedAt(\n            id,\n            lastSeqArray[posOld[idStringify(id)]],\n            prevPosition\n          );\n        }\n      });\n\n      _.each(posNew, function (pos, idString) {\n        if (!_.has(posOld, idString)) return;\n\n        var id = idParse(idString);\n        var newItem = seqArray[pos] || {};\n        var oldItem = lastSeqArray[posOld[idString]];\n        var updates = getUpdates(oldItem, newItem, preventNestedDiff);\n\n        if (!_.isEmpty(updates))\n          callbacks.changedAt(id, updates, pos, oldItem);\n      });\n    }\n\n    diffArray.shallow = function(lastSeqArray, seqArray, callbacks) {\n      return diffArray(lastSeqArray, seqArray, callbacks, true);\n    };\n\n    diffArray.deepCopyChanges = function (oldItem, newItem) {\n      var setDiff = getUpdates(oldItem, newItem).$set;\n\n      _.each(setDiff, function(v, deepKey) {\n        setDeep(oldItem, deepKey, v);\n      });\n    };\n\n    diffArray.deepCopyRemovals = function (oldItem, newItem) {\n      var unsetDiff = getUpdates(oldItem, newItem).$unset;\n\n      _.each(unsetDiff, function(v, deepKey) {\n        unsetDeep(oldItem, deepKey);\n      });\n    };\n\n    // Finds changes between two collections\n    diffArray.getChanges = function(newCollection, oldCollection, diffMethod) {\n      var changes = {added: [], removed: [], changed: []};\n\n      diffMethod(oldCollection, newCollection, {\n        addedAt: function(id, item, index) {\n          changes.added.push({item: item, index: index});\n        },\n\n        removedAt: function(id, item, index) {\n          changes.removed.push({item: item, index: index});\n        },\n\n        changedAt: function(id, updates, index, oldItem) {\n          changes.changed.push({selector: id, modifier: updates});\n        },\n\n        movedTo: function(id, item, fromIndex, toIndex) {\n          // XXX do we need this?\n        }\n      });\n\n      return changes;\n    };\n\n    var setDeep = function(obj, deepKey, v) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n\n      initialKeys.reduce(function(subObj, k, i) {\n        var nextKey = split[i + 1];\n\n        if (isNumStr(nextKey)) {\n          if (subObj[k] === null) subObj[k] = [];\n          if (subObj[k].length == parseInt(nextKey)) subObj[k].push(null);\n        }\n\n        else if (subObj[k] === null || !isHash(subObj[k])) {\n          subObj[k] = {};\n        }\n\n        return subObj[k];\n      }, obj);\n\n      var deepObj = getDeep(obj, initialKeys);\n      deepObj[lastKey] = v;\n      return v;\n    };\n\n    var unsetDeep = function(obj, deepKey) {\n      var split = deepKey.split('.');\n      var initialKeys = _.initial(split);\n      var lastKey = _.last(split);\n      var deepObj = getDeep(obj, initialKeys);\n\n      if (_.isArray(deepObj) && isNumStr(lastKey))\n        return !!deepObj.splice(lastKey, 1);\n      else\n        return delete deepObj[lastKey];\n    };\n\n    var getDeep = function(obj, keys) {\n      return keys.reduce(function(subObj, k) {\n        return subObj[k];\n      }, obj);\n    };\n\n    var isHash = function(obj) {\n      return _.isObject(obj) &&\n             Object.getPrototypeOf(obj) === Object.prototype;\n    };\n\n    var isNumStr = function(str) {\n      return str.match(/^\\d+$/);\n    };\n\n    return diffArray;\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/diff-array.js\n **/","angular.module('angular-meteor.settings', [])\n  .constant('$angularMeteorSettings', {\n    suppressWarnings: false\n  });\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-settings.js\n **/","angular.module('angular-meteor.ironrouter', [])\n\n\n.run([\n  '$compile',\n  '$document',\n  '$rootScope',\n\nfunction ($compile, $document, $rootScope) {\n  const Router = (Package['iron:router'] || {}).Router;\n  if (!Router) return;\n\n  let isLoaded = false;\n\n  // Recompile after iron:router builds page\n  Router.onAfterAction((req, res, next) => {\n    Tracker.afterFlush(() => {\n      if (isLoaded) return;\n      $compile($document)($rootScope);\n      if (!$rootScope.$$phase) $rootScope.$apply();\n      isLoaded = true;\n    });\n  });\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-ironrouter.js\n **/","/*global\n angular, _, Tracker, EJSON, FS, Mongo\n */\n\n'use strict';\n\nvar angularMeteorUtils = angular.module('angular-meteor.utils', ['angular-meteor.settings']);\n\nangularMeteorUtils.service('$meteorUtils', [\n  '$q', '$timeout', '$angularMeteorSettings',\n  function ($q, $timeout, $angularMeteorSettings) {\n\n    var self = this;\n\n    this.autorun = function(scope, fn) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.utils.autorun] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.6/autorun. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n\n      // wrapping around Deps.autorun\n      var comp = Tracker.autorun(function(c) {\n        fn(c);\n        // this is run immediately for the first call\n        // but after that, we need to $apply to start Angular digest\n        if (!c.firstRun) $timeout(angular.noop, 0);\n      });\n\n      // stop autorun when scope is destroyed\n      scope.$on('$destroy', function() {\n        comp.stop();\n      });\n\n      // return autorun object so that it can be stopped manually\n      return comp;\n    };\n\n    // Borrowed from angularFire\n    // https://github.com/firebase/angularfire/blob/master/src/utils.js#L445-L454\n    this.stripDollarPrefixedKeys = function (data) {\n      if (!_.isObject(data) ||\n          data instanceof Date ||\n          data instanceof File ||\n          EJSON.toJSONValue(data).$type === 'oid' ||\n          (typeof FS === 'object' && data instanceof FS.File))\n        return data;\n\n      var out = _.isArray(data) ? [] : {};\n\n      _.each(data, function(v,k) {\n        if(typeof k !== 'string' || k.charAt(0) !== '$')\n          out[k] = self.stripDollarPrefixedKeys(v);\n      });\n\n      return out;\n    };\n\n    // Returns a callback which fulfills promise\n    this.fulfill = function(deferred, boundError, boundResult) {\n      return function(err, result) {\n        if (err)\n          deferred.reject(boundError == null ? err : boundError);\n        else if (typeof boundResult == \"function\")\n          deferred.resolve(boundResult == null ? result : boundResult(result));\n        else\n          deferred.resolve(boundResult == null ? result : boundResult);\n      };\n    };\n\n    // creates a function which invokes method with the given arguments and returns a promise\n    this.promissor = function(obj, method) {\n      return function() {\n        var deferred = $q.defer();\n        var fulfill = self.fulfill(deferred);\n        var args = _.toArray(arguments).concat(fulfill);\n        obj[method].apply(obj, args);\n        return deferred.promise;\n      };\n    };\n\n    // creates a $q.all() promise and call digestion loop on fulfillment\n    this.promiseAll = function(promises) {\n      var allPromise = $q.all(promises);\n\n      allPromise.finally(function() {\n        // calls digestion loop with no conflicts\n        $timeout(angular.noop);\n      });\n\n      return allPromise;\n    };\n\n    this.getCollectionByName = function(string){\n      return Mongo.Collection.get(string);\n    };\n\n    this.findIndexById = function(collection, doc) {\n      var foundDoc = _.find(collection, function(colDoc) {\n        // EJSON.equals used to compare Mongo.ObjectIDs and Strings.\n        return EJSON.equals(colDoc._id, doc._id);\n      });\n\n      return _.indexOf(collection, foundDoc);\n    };\n  }\n]);\n\nangularMeteorUtils.run([\n  '$rootScope', '$meteorUtils',\n  function($rootScope, $meteorUtils) {\n    Object.getPrototypeOf($rootScope).$meteorAutorun = function(fn) {\n      return $meteorUtils.autorun(this, fn);\n    };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-utils.js\n **/","/*global\n angular, Meteor\n */\n\n'use strict';\nvar angularMeteorSubscribe = angular.module('angular-meteor.subscribe', ['angular-meteor.settings']);\n\nangularMeteorSubscribe.service('$meteorSubscribe', ['$q', '$angularMeteorSettings',\n  function ($q, $angularMeteorSettings) {\n\n    var self = this;\n\n    this._subscribe = function(scope, deferred, args) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.subscribe] Please note that this module is deprecated since 1.3.0 and will be removed in 1.4.0! Replace it with the new syntax described here: http://www.angular-meteor.com/api/1.3.6/subscribe. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var subscription = null;\n      var lastArg = args[args.length - 1];\n\n      // User supplied onStop callback\n      // save it for later use and remove\n      // from subscription arguments\n      if (angular.isObject(lastArg) &&\n          angular.isFunction(lastArg.onStop)) {\n        var onStop = lastArg.onStop;\n\n        args.pop();\n      }\n\n      args.push({\n        onReady: function() {\n          deferred.resolve(subscription);\n        },\n        onStop: function(err) {\n          if (!deferred.promise.$$state.status) {\n            if (err)\n              deferred.reject(err);\n            else\n              deferred.reject(new Meteor.Error(\"Subscription Stopped\",\n                \"Subscription stopped by a call to stop method. Either by the client or by the server.\"));\n          } else if (onStop)\n            // After promise was resolved or rejected\n            // call user supplied onStop callback.\n            onStop.apply(this, Array.prototype.slice.call(arguments));\n\n        }\n      });\n\n      subscription =  Meteor.subscribe.apply(scope, args);\n\n      return subscription;\n    };\n\n    this.subscribe = function(){\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n      var subscription = null;\n\n      self._subscribe(this, deferred, args);\n\n      return deferred.promise;\n    };\n  }]);\n\nangularMeteorSubscribe.run(['$rootScope', '$q', '$meteorSubscribe',\n  function($rootScope, $q, $meteorSubscribe) {\n    Object.getPrototypeOf($rootScope).$meteorSubscribe = function() {\n      var deferred = $q.defer();\n      var args = Array.prototype.slice.call(arguments);\n\n      var subscription = $meteorSubscribe._subscribe(this, deferred, args);\n\n      this.$on('$destroy', function() {\n        subscription.stop();\n      });\n\n      return deferred.promise;\n    };\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-subscribe.js\n **/","/*global\n angular, _, Tracker, check, Match, Mongo\n */\n\n'use strict';\n\nvar angularMeteorCollection = angular.module('angular-meteor.collection',\n  ['angular-meteor.stopper', 'angular-meteor.subscribe', 'angular-meteor.utils', 'diffArray', 'angular-meteor.settings']);\n\n// The reason angular meteor collection is a factory function and not something\n// that inherit from array comes from here:\n// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/\n// We went with the direct extensions approach.\nangularMeteorCollection.factory('AngularMeteorCollection', [\n  '$q', '$meteorSubscribe', '$meteorUtils', '$rootScope', '$timeout', 'diffArray', '$angularMeteorSettings',\n  function($q, $meteorSubscribe, $meteorUtils, $rootScope, $timeout, diffArray, $angularMeteorSettings) {\n\n    function AngularMeteorCollection(curDefFunc, collection, diffArrayFunc, autoClientSave) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorCollection] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorCollection. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var data = [];\n      // Server backup data to evaluate what changes come from client\n      // after each server update.\n      data._serverBackup = [];\n      // Array differ function.\n      data._diffArrayFunc = diffArrayFunc;\n      // Handler of the cursor observer.\n      data._hObserve = null;\n      // On new cursor autorun handler\n      // (autorun for reactive variables).\n      data._hNewCurAutorun = null;\n      // On new data autorun handler\n      // (autorun for cursor.fetch).\n      data._hDataAutorun = null;\n\n      if (angular.isDefined(collection)) {\n        data.$$collection = collection;\n      } else {\n        var cursor = curDefFunc();\n        data.$$collection = $meteorUtils.getCollectionByName(cursor.collection.name);\n      }\n\n      _.extend(data, AngularMeteorCollection);\n      data._startCurAutorun(curDefFunc, autoClientSave);\n\n      return data;\n    }\n\n    AngularMeteorCollection._startCurAutorun = function(curDefFunc, autoClientSave) {\n      var self = this;\n\n      self._hNewCurAutorun = Tracker.autorun(function() {\n        // When the reactive func gets recomputated we need to stop any previous\n        // observeChanges.\n        Tracker.onInvalidate(function() {\n          self._stopCursor();\n        });\n\n        if (autoClientSave) self._setAutoClientSave();\n        self._updateCursor(curDefFunc(), autoClientSave);\n      });\n    };\n\n    AngularMeteorCollection.subscribe = function() {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorCollection.save = function(docs, useUnsetModifier) {\n      // save whole collection\n      if (!docs) docs = this;\n      // save single doc\n      docs = [].concat(docs);\n\n      var promises = docs.map(function(doc) {\n        return this._upsertDoc(doc, useUnsetModifier);\n      }, this);\n\n      return $meteorUtils.promiseAll(promises);\n    };\n\n    AngularMeteorCollection._upsertDoc = function(doc, useUnsetModifier) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n\n      // delete $$hashkey\n      doc = $meteorUtils.stripDollarPrefixedKeys(doc);\n      var docId = doc._id;\n      var isExist = collection.findOne(docId);\n\n      // update\n      if (isExist) {\n        // Deletes _id property (from the copy) so that\n        // it can be $set using update.\n        delete doc._id;\n        var modifier = useUnsetModifier ? {$unset: doc} : {$set: doc};\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\n        collection.update(docId, modifier, createFulfill(function() {\n          return {_id: docId, action: 'updated'};\n        }));\n      }\n      // insert\n      else {\n        collection.insert(doc, createFulfill(function(id) {\n          return {_id: id, action: 'inserted'};\n        }));\n      }\n\n      return deferred.promise;\n    };\n\n    // performs $pull operations parallely.\n    // used for handling splice operations returned from getUpdates() to prevent conflicts.\n    // see issue: https://github.com/Urigo/angular-meteor/issues/793\n    AngularMeteorCollection._updateDiff = function(selector, update, callback) {\n      callback = callback || angular.noop;\n      var setters = _.omit(update, '$pull');\n      var updates = [setters];\n\n      _.each(update.$pull, function(pull, prop) {\n        var puller = {};\n        puller[prop] = pull;\n        updates.push({ $pull: puller });\n      });\n\n      this._updateParallel(selector, updates, callback);\n    };\n\n    // performs each update operation parallely\n    AngularMeteorCollection._updateParallel = function(selector, updates, callback) {\n      var self = this;\n      var done = _.after(updates.length, callback);\n\n      var next = function(err, affectedDocsNum) {\n        if (err) return callback(err);\n        done(null, affectedDocsNum);\n      };\n\n      _.each(updates, function(update) {\n        self.$$collection.update(selector, update, next);\n      });\n    };\n\n    AngularMeteorCollection.remove = function(keyOrDocs) {\n      var keys;\n\n      // remove whole collection\n      if (!keyOrDocs) {\n        keys = _.pluck(this, '_id');\n      }\n      // remove docs\n      else {\n        keyOrDocs = [].concat(keyOrDocs);\n\n        keys = _.map(keyOrDocs, function(keyOrDoc) {\n          return keyOrDoc._id || keyOrDoc;\n        });\n      }\n\n      // Checks if all keys are correct.\n      check(keys, [Match.OneOf(String, Mongo.ObjectID)]);\n\n      var promises = keys.map(function(key) {\n        return this._removeDoc(key);\n      }, this);\n\n      return $meteorUtils.promiseAll(promises);\n    };\n\n    AngularMeteorCollection._removeDoc = function(id) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var fulfill = $meteorUtils.fulfill(deferred, null, { _id: id, action: 'removed' });\n      collection.remove(id, fulfill);\n      return deferred.promise;\n    };\n\n    AngularMeteorCollection._updateCursor = function(cursor, autoClientSave) {\n      var self = this;\n      // XXX - consider adding an option for a non-orderd result for faster performance\n      if (self._hObserve) self._stopObserving();\n\n\n      self._hObserve = cursor.observe({\n        addedAt: function(doc, atIndex) {\n          self.splice(atIndex, 0, doc);\n          self._serverBackup.splice(atIndex, 0, doc);\n          self._setServerUpdateMode();\n        },\n\n        changedAt: function(doc, oldDoc, atIndex) {\n          diffArray.deepCopyChanges(self[atIndex], doc);\n          diffArray.deepCopyRemovals(self[atIndex], doc);\n          self._serverBackup[atIndex] = self[atIndex];\n          self._setServerUpdateMode();\n        },\n\n        movedTo: function(doc, fromIndex, toIndex) {\n          self.splice(fromIndex, 1);\n          self.splice(toIndex, 0, doc);\n          self._serverBackup.splice(fromIndex, 1);\n          self._serverBackup.splice(toIndex, 0, doc);\n          self._setServerUpdateMode();\n        },\n\n        removedAt: function(oldDoc) {\n          var removedIndex = $meteorUtils.findIndexById(self, oldDoc);\n\n          if (removedIndex != -1) {\n            self.splice(removedIndex, 1);\n            self._serverBackup.splice(removedIndex, 1);\n            self._setServerUpdateMode();\n          } else {\n            // If it's been removed on client then it's already not in collection\n            // itself but still is in the _serverBackup.\n            removedIndex = $meteorUtils.findIndexById(self._serverBackup, oldDoc);\n\n            if (removedIndex != -1) {\n              self._serverBackup.splice(removedIndex, 1);\n            }\n          }\n        }\n      });\n\n      self._hDataAutorun = Tracker.autorun(function() {\n        cursor.fetch();\n        if (self._serverMode) self._unsetServerUpdateMode(autoClientSave);\n      });\n    };\n\n    AngularMeteorCollection._stopObserving = function() {\n      this._hObserve.stop();\n      this._hDataAutorun.stop();\n      delete this._serverMode;\n      delete this._hUnsetTimeout;\n    };\n\n    AngularMeteorCollection._setServerUpdateMode = function(name) {\n      this._serverMode = true;\n      // To simplify server update logic, we don't follow\n      // updates from the client at the same time.\n      this._unsetAutoClientSave();\n    };\n\n    // Here we use $timeout to combine multiple updates that go\n    // each one after another.\n    AngularMeteorCollection._unsetServerUpdateMode = function(autoClientSave) {\n      var self = this;\n\n      if (self._hUnsetTimeout) {\n        $timeout.cancel(self._hUnsetTimeout);\n        self._hUnsetTimeout = null;\n      }\n\n      self._hUnsetTimeout = $timeout(function() {\n        self._serverMode = false;\n        // Finds updates that was potentially done from the client side\n        // and saves them.\n        var changes = diffArray.getChanges(self, self._serverBackup, self._diffArrayFunc);\n        self._saveChanges(changes);\n        // After, continues following client updates.\n        if (autoClientSave) self._setAutoClientSave();\n      }, 0);\n    };\n\n    AngularMeteorCollection.stop = function() {\n      this._stopCursor();\n      this._hNewCurAutorun.stop();\n    };\n\n    AngularMeteorCollection._stopCursor = function() {\n      this._unsetAutoClientSave();\n\n      if (this._hObserve) {\n        this._hObserve.stop();\n        this._hDataAutorun.stop();\n      }\n\n      this.splice(0);\n      this._serverBackup.splice(0);\n    };\n\n    AngularMeteorCollection._unsetAutoClientSave = function(name) {\n      if (this._hRegAutoBind) {\n        this._hRegAutoBind();\n        this._hRegAutoBind = null;\n      }\n    };\n\n    AngularMeteorCollection._setAutoClientSave = function() {\n      var self = this;\n\n      // Always unsets auto save to keep only one $watch handler.\n      self._unsetAutoClientSave();\n\n      self._hRegAutoBind = $rootScope.$watch(function() {\n        return self;\n      }, function(nItems, oItems) {\n        if (nItems === oItems) return;\n\n        var changes = diffArray.getChanges(self, oItems, self._diffArrayFunc);\n        self._unsetAutoClientSave();\n        self._saveChanges(changes);\n        self._setAutoClientSave();\n      }, true);\n    };\n\n    AngularMeteorCollection._saveChanges = function(changes) {\n      var self = this;\n\n      // Saves added documents\n      // Using reversed iteration to prevent indexes from changing during splice\n      var addedDocs = changes.added.reverse().map(function(descriptor) {\n        self.splice(descriptor.index, 1);\n        return descriptor.item;\n      });\n\n      if (addedDocs.length) self.save(addedDocs);\n\n      // Removes deleted documents\n      var removedDocs = changes.removed.map(function(descriptor) {\n        return descriptor.item;\n      });\n\n      if (removedDocs.length) self.remove(removedDocs);\n\n      // Updates changed documents\n      changes.changed.forEach(function(descriptor) {\n        self._updateDiff(descriptor.selector, descriptor.modifier);\n      });\n    };\n\n    return AngularMeteorCollection;\n}]);\n\nangularMeteorCollection.factory('$meteorCollectionFS', [\n  '$meteorCollection', 'diffArray', '$angularMeteorSettings',\n  function($meteorCollection, diffArray, $angularMeteorSettings) {\n    function $meteorCollectionFS(reactiveFunc, autoClientSave, collection) {\n\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorCollectionFS] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/files. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      return new $meteorCollection(reactiveFunc, autoClientSave, collection, diffArray.shallow);\n    }\n\n    return $meteorCollectionFS;\n}]);\n\nangularMeteorCollection.factory('$meteorCollection', [\n  'AngularMeteorCollection', '$rootScope', 'diffArray',\n  function(AngularMeteorCollection, $rootScope, diffArray) {\n    function $meteorCollection(reactiveFunc, autoClientSave, collection, diffFn) {\n      // Validate parameters\n      if (!reactiveFunc) {\n        throw new TypeError('The first argument of $meteorCollection is undefined.');\n      }\n\n      if (!(angular.isFunction(reactiveFunc) || angular.isFunction(reactiveFunc.find))) {\n        throw new TypeError(\n          'The first argument of $meteorCollection must be a function or ' +\n            'a have a find function property.');\n      }\n\n      if (!angular.isFunction(reactiveFunc)) {\n        collection = angular.isDefined(collection) ? collection : reactiveFunc;\n        reactiveFunc = _.bind(reactiveFunc.find, reactiveFunc);\n      }\n\n      // By default auto save - true.\n      autoClientSave = angular.isDefined(autoClientSave) ? autoClientSave : true;\n      diffFn = diffFn || diffArray;\n      return new AngularMeteorCollection(reactiveFunc, collection, diffFn, autoClientSave);\n    }\n\n    return $meteorCollection;\n}]);\n\nangularMeteorCollection.run([\n  '$rootScope', '$meteorCollection', '$meteorCollectionFS', '$meteorStopper',\n  function($rootScope, $meteorCollection, $meteorCollectionFS, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorCollection = $meteorStopper($meteorCollection);\n    scopeProto.$meteorCollectionFS = $meteorStopper($meteorCollectionFS);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-collection.js\n **/","/*global\n  angular, _, Mongo\n*/\n\n'use strict';\n\nvar angularMeteorObject = angular.module('angular-meteor.object',\n  ['angular-meteor.utils', 'angular-meteor.subscribe', 'angular-meteor.collection', 'getUpdates', 'diffArray', 'angular-meteor.settings']);\n\nangularMeteorObject.factory('AngularMeteorObject', [\n  '$q', '$meteorSubscribe', '$meteorUtils', 'diffArray', 'getUpdates', 'AngularMeteorCollection', '$angularMeteorSettings',\n  function($q, $meteorSubscribe, $meteorUtils, diffArray, getUpdates, AngularMeteorCollection, $angularMeteorSettings) {\n\n    // A list of internals properties to not watch for, nor pass to the Document on update and etc.\n    AngularMeteorObject.$$internalProps = [\n      '$$collection', '$$options', '$$id', '$$hashkey', '$$internalProps', '$$scope',\n      'bind', 'save', 'reset', 'subscribe', 'stop', 'autorunComputation', 'unregisterAutoBind', 'unregisterAutoDestroy', 'getRawObject',\n      '_auto', '_setAutos', '_eventEmitter', '_serverBackup', '_updateDiff', '_updateParallel', '_getId'\n    ];\n\n    function AngularMeteorObject (collection, selector, options){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteorObject] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/meteorObject. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      // Make data not be an object so we can extend it to preserve\n      // Collection Helpers and the like\n      var helpers = collection._helpers;\n      var data = _.isFunction(helpers) ? Object.create(helpers.prototype) : {};\n      var doc = collection.findOne(selector, options);\n      var collectionExtension = _.pick(AngularMeteorCollection, '_updateParallel');\n      _.extend(data, doc);\n      _.extend(data, AngularMeteorObject);\n      _.extend(data, collectionExtension);\n\n      // Omit options that may spoil document finding\n      data.$$options = _.omit(options, 'skip', 'limit');\n      data.$$collection = collection;\n      data.$$id = data._getId(selector);\n      data._serverBackup = doc || {};\n\n      return data;\n    }\n\n    AngularMeteorObject.getRawObject = function () {\n      return angular.copy(_.omit(this, this.$$internalProps));\n    };\n\n    AngularMeteorObject.subscribe = function () {\n      $meteorSubscribe.subscribe.apply(this, arguments);\n      return this;\n    };\n\n    AngularMeteorObject.save = function(custom) {\n      var deferred = $q.defer();\n      var collection = this.$$collection;\n      var createFulfill = _.partial($meteorUtils.fulfill, deferred, null);\n      var oldDoc = collection.findOne(this.$$id);\n      var mods;\n\n      // update\n      if (oldDoc) {\n        if (custom)\n          mods = { $set: custom };\n        else {\n          mods = getUpdates(oldDoc, this.getRawObject());\n          // If there are no updates, there is nothing to do here, returning\n          if (_.isEmpty(mods)) {\n            return $q.when({ action: 'updated' });\n          }\n        }\n\n        // NOTE: do not use #upsert() method, since it does not exist in some collections\n        this._updateDiff(mods, createFulfill({ action: 'updated' }));\n      }\n      // insert\n      else {\n        if (custom)\n          mods = _.clone(custom);\n        else\n          mods = this.getRawObject();\n\n        mods._id = mods._id || this.$$id;\n        collection.insert(mods, createFulfill({ action: 'inserted' }));\n      }\n\n      return deferred.promise;\n    };\n\n    AngularMeteorObject._updateDiff = function(update, callback) {\n      var selector = this.$$id;\n      AngularMeteorCollection._updateDiff.call(this, selector, update, callback);\n    };\n\n    AngularMeteorObject.reset = function(keepClientProps) {\n      var self = this;\n      var options = this.$$options;\n      var id = this.$$id;\n      var doc = this.$$collection.findOne(id, options);\n\n      if (doc) {\n        // extend SubObject\n        var docKeys = _.keys(doc);\n        var docExtension = _.pick(doc, docKeys);\n        var clientProps;\n\n        _.extend(self, docExtension);\n        _.extend(self._serverBackup, docExtension);\n\n        if (keepClientProps) {\n          clientProps = _.intersection(_.keys(self), _.keys(self._serverBackup));\n        } else {\n          clientProps = _.keys(self);\n        }\n\n        var serverProps = _.keys(doc);\n        var removedKeys = _.difference(clientProps, serverProps, self.$$internalProps);\n\n        removedKeys.forEach(function (prop) {\n          delete self[prop];\n          delete self._serverBackup[prop];\n        });\n      }\n\n      else {\n        _.keys(this.getRawObject()).forEach(function(prop) {\n          delete self[prop];\n        });\n\n        self._serverBackup = {};\n      }\n    };\n\n    AngularMeteorObject.stop = function () {\n      if (this.unregisterAutoDestroy)\n        this.unregisterAutoDestroy();\n\n      if (this.unregisterAutoBind)\n        this.unregisterAutoBind();\n\n      if (this.autorunComputation && this.autorunComputation.stop)\n        this.autorunComputation.stop();\n    };\n\n    AngularMeteorObject._getId = function(selector) {\n      var options = _.extend({}, this.$$options, {\n        fields: { _id: 1 },\n        reactive: false,\n        transform: null\n      });\n\n      var doc = this.$$collection.findOne(selector, options);\n\n      if (doc) return doc._id;\n      if (selector instanceof Mongo.ObjectID) return selector;\n      if (_.isString(selector)) return selector;\n      return new Mongo.ObjectID();\n    };\n\n    return AngularMeteorObject;\n}]);\n\n\nangularMeteorObject.factory('$meteorObject', [\n  '$rootScope', '$meteorUtils', 'getUpdates', 'AngularMeteorObject',\n  function($rootScope, $meteorUtils, getUpdates, AngularMeteorObject) {\n    function $meteorObject(collection, id, auto, options) {\n      // Validate parameters\n      if (!collection) {\n        throw new TypeError(\"The first argument of $meteorObject is undefined.\");\n      }\n\n      if (!angular.isFunction(collection.findOne)) {\n        throw new TypeError(\"The first argument of $meteorObject must be a function or a have a findOne function property.\");\n      }\n\n      var data = new AngularMeteorObject(collection, id, options);\n      // Making auto default true - http://stackoverflow.com/a/15464208/1426570\n      data._auto = auto !== false;\n      _.extend(data, $meteorObject);\n      data._setAutos();\n      return data;\n    }\n\n    $meteorObject._setAutos = function() {\n      var self = this;\n\n      this.autorunComputation = $meteorUtils.autorun($rootScope, function() {\n        self.reset(true);\n      });\n\n      // Deep watches the model and performs autobind\n      this.unregisterAutoBind = this._auto && $rootScope.$watch(function(){\n        return self.getRawObject();\n      }, function (item, oldItem) {\n        if (item !== oldItem) self.save();\n      }, true);\n\n      this.unregisterAutoDestroy = $rootScope.$on('$destroy', function() {\n        if (self && self.stop) self.pop();\n      });\n    };\n\n    return $meteorObject;\n}]);\n\nangularMeteorObject.run([\n  '$rootScope', '$meteorObject', '$meteorStopper',\n  function ($rootScope, $meteorObject, $meteorStopper) {\n    var scopeProto = Object.getPrototypeOf($rootScope);\n    scopeProto.$meteorObject = $meteorStopper($meteorObject);\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-object.js\n **/","/*global\n angular, _, Package, Meteor\n */\n\n'use strict';\n\nvar angularMeteorUser = angular.module('angular-meteor.user', [\n  'angular-meteor.utils',\n  'angular-meteor.core',\n  'angular-meteor.settings'\n]);\n\n// requires package 'accounts-password'\nangularMeteorUser.service('$meteorUser', [\n  '$rootScope', '$meteorUtils', '$q', '$angularMeteorSettings',\n  function($rootScope, $meteorUtils, $q, $angularMeteorSettings){\n\n    var pack = Package['accounts-base'];\n    if (!pack) return;\n\n    var self = this;\n    var Accounts = pack.Accounts;\n\n    this.waitForUser = function(){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.waitForUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() )\n          deferred.resolve( Meteor.user() );\n      }, true);\n\n      return deferred.promise;\n    };\n\n    this.requireUser = function(){\n      if (!$angularMeteorSettings.suppressWarnings) {\n        console.warn('[angular-meteor.requireUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n      }\n\n      var deferred = $q.defer();\n\n      $meteorUtils.autorun($rootScope, function(){\n        if ( !Meteor.loggingIn() ) {\n          if ( Meteor.user() === null)\n            deferred.reject(\"AUTH_REQUIRED\");\n          else\n            deferred.resolve( Meteor.user() );\n        }\n      }, true);\n\n      return deferred.promise;\n    };\n\n    this.requireValidUser = function(validatorFn) {\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.requireValidUser] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://info.meteor.com/blog/angular-meteor-1.3. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      return self.requireUser(true).then(function(user){\n        var valid = validatorFn( user );\n\n        if ( valid === true )\n          return user;\n        else if ( typeof valid === \"string\" )\n          return $q.reject( valid );\n        else\n          return $q.reject( \"FORBIDDEN\" );\n\t    });\n\t  };\n\n    this.loginWithPassword = $meteorUtils.promissor(Meteor, 'loginWithPassword');\n    this.createUser = $meteorUtils.promissor(Accounts, 'createUser');\n    this.changePassword = $meteorUtils.promissor(Accounts, 'changePassword');\n    this.forgotPassword = $meteorUtils.promissor(Accounts, 'forgotPassword');\n    this.resetPassword = $meteorUtils.promissor(Accounts, 'resetPassword');\n    this.verifyEmail = $meteorUtils.promissor(Accounts, 'verifyEmail');\n    this.logout = $meteorUtils.promissor(Meteor, 'logout');\n    this.logoutOtherClients = $meteorUtils.promissor(Meteor, 'logoutOtherClients');\n    this.loginWithFacebook = $meteorUtils.promissor(Meteor, 'loginWithFacebook');\n    this.loginWithTwitter = $meteorUtils.promissor(Meteor, 'loginWithTwitter');\n    this.loginWithGoogle = $meteorUtils.promissor(Meteor, 'loginWithGoogle');\n    this.loginWithGithub = $meteorUtils.promissor(Meteor, 'loginWithGithub');\n    this.loginWithMeteorDeveloperAccount = $meteorUtils.promissor(Meteor, 'loginWithMeteorDeveloperAccount');\n    this.loginWithMeetup = $meteorUtils.promissor(Meteor, 'loginWithMeetup');\n    this.loginWithWeibo = $meteorUtils.promissor(Meteor, 'loginWithWeibo');\n  }\n]);\n\nangularMeteorUser.run([\n  '$rootScope', '$angularMeteorSettings', '$$Core',\n  function($rootScope, $angularMeteorSettings, $$Core){\n\n    let ScopeProto = Object.getPrototypeOf($rootScope);\n    _.extend(ScopeProto, $$Core);\n\n    $rootScope.autorun(function(){\n      if (!Meteor.user) return;\n      $rootScope.currentUser = Meteor.user();\n      $rootScope.loggingIn = Meteor.loggingIn();\n    });\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-user.js\n **/","/*global\n angular, _, Meteor\n */\n\n'use strict';\n\nvar angularMeteorMethods = angular.module('angular-meteor.methods', ['angular-meteor.utils', 'angular-meteor.settings']);\n\nangularMeteorMethods.service('$meteorMethods', [\n  '$q', '$meteorUtils', '$angularMeteorSettings',\n  function($q, $meteorUtils, $angularMeteorSettings) {\n    this.call = function(){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.$meteor.call] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/methods. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      var deferred = $q.defer();\n      var fulfill = $meteorUtils.fulfill(deferred);\n      var args = _.toArray(arguments).concat(fulfill);\n      Meteor.call.apply(this, args);\n      return deferred.promise;\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-methods.js\n **/","/*global\n angular, Session\n */\n\n'use strict';\nvar angularMeteorSession = angular.module('angular-meteor.session', ['angular-meteor.utils', 'angular-meteor.settings']);\n\nangularMeteorSession.factory('$meteorSession', ['$meteorUtils', '$parse', '$angularMeteorSettings',\n  function ($meteorUtils, $parse, $angularMeteorSettings) {\n    return function (session) {\n\n      return {\n\n        bind: function(scope, model) {\n          if (!$angularMeteorSettings.suppressWarnings)\n            console.warn('[angular-meteor.session.bind] Please note that this method is deprecated since 1.3.0 and will be removed in 1.4.0! http://www.angular-meteor.com/api/1.3.0/session. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n          var getter = $parse(model);\n          var setter = getter.assign;\n          $meteorUtils.autorun(scope, function() {\n            setter(scope, Session.get(session));\n          });\n\n          scope.$watch(model, function(newItem, oldItem) {\n            Session.set(session, getter(scope));\n          }, true);\n\n        }\n      };\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-session.js\n **/","/*global\n angular, Package\n */\n\n'use strict';\n\nvar angularMeteorCamera = angular.module('angular-meteor.camera', ['angular-meteor.utils', 'angular-meteor.settings']);\n\n// requires package 'mdg:camera'\nangularMeteorCamera.service('$meteorCamera', [\n  '$q', '$meteorUtils', '$angularMeteorSettings',\n  function ($q, $meteorUtils, $angularMeteorSettings) {\n    if (!$angularMeteorSettings.suppressWarnings)\n      console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n    var pack = Package['mdg:camera'];\n    if (!pack) return;\n\n    var MeteorCamera = pack.MeteorCamera;\n\n    this.getPicture = function(options){\n      if (!$angularMeteorSettings.suppressWarnings)\n        console.warn('[angular-meteor.camera] Please note that this module has moved to a separate package and is deprecated since 1.3.0 and will be removed in 1.4.0! For more info: http://www.angular-meteor.com/api/1.3.0/camera. You can disable this warning by following this guide http://www.angular-meteor.com/api/1.3.6/settings');\n\n      options = options || {};\n      var deferred = $q.defer();\n      MeteorCamera.getPicture(options, $meteorUtils.fulfill(deferred));\n      return deferred.promise;\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-camera.js\n **/","/*global\n angular\n */\n\n'use strict';\n\nvar angularMeteorStopper = angular.module('angular-meteor.stopper',\n  ['angular-meteor.subscribe']);\n\nangularMeteorStopper.factory('$meteorStopper', ['$q', '$meteorSubscribe',\n  function($q, $meteorSubscribe) {\n    function $meteorStopper($meteorEntity) {\n      return function() {\n        var args = Array.prototype.slice.call(arguments);\n        var meteorEntity = $meteorEntity.apply(this, args);\n\n        angular.extend(meteorEntity, $meteorStopper);\n        meteorEntity.$$scope = this;\n\n        this.$on('$destroy', function () {\n          meteorEntity.stop();\n          if (meteorEntity.subscription) meteorEntity.subscription.stop();\n        });\n\n        return meteorEntity;\n      };\n    }\n\n    $meteorStopper.subscribe = function() {\n      var args = Array.prototype.slice.call(arguments);\n      this.subscription = $meteorSubscribe._subscribe(this.$$scope, $q.defer(), args);\n      return this;\n    };\n\n    return $meteorStopper;\n}]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/angular-meteor-stopper.js\n **/","export const name = 'angular-meteor.utilities';\nexport const utils = '$$utils';\n\nangular.module(name, [])\n\n/*\n  A utility service which is provided with general utility functions\n */\n.service(utils, [\n  '$rootScope',\n\n  function($rootScope) {\n    const self = this;\n\n    // Checks if an object is a cursor\n    this.isCursor = (obj) => {\n      return obj instanceof Meteor.Collection.Cursor;\n    };\n\n    // Cheecks if an object is a scope\n    this.isScope = (obj) => {\n      return obj instanceof $rootScope.constructor;\n    };\n\n    // Checks if an object is a view model\n    this.isViewModel = (obj) => {\n      return _.isObject(obj) && obj.$$dependencies;\n    };\n\n    // Checks if two objects are siblings\n    this.areSiblings = (obj1, obj2) => {\n      return _.isObject(obj1) && _.isObject(obj2) &&\n        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2);\n    };\n\n    // Binds function into a scpecified context. If an object is provided, will bind every\n    // value in the object which is a function. If a tap function is provided, it will be\n    // called right after the function has been invoked.\n    this.bind = (fn, context, tap) => {\n      tap = _.isFunction(tap) ? tap : angular.noop;\n      if (_.isFunction(fn)) return bindFn(fn, context, tap);\n      if (_.isObject(fn)) return bindObj(fn, context, tap);\n      return fn;\n    };\n\n    function bindFn(fn, context, tap) {\n      return (...args) => {\n        const result = fn.apply(context, args);\n        tap.call(context, {\n          result,\n          args\n        });\n        return result;\n      };\n    }\n\n    function bindObj(obj, context, tap) {\n      return _.keys(obj).reduce((bound, k) => {\n        bound[k] = self.bind(obj[k], context, tap);\n        return bound;\n      }, {});\n    }\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/utils.js\n **/","export const name = 'angular-meteor.mixer';\nexport const Mixer = '$Mixer';\n\nangular.module(name, [])\n\n/*\n  A service which lets us apply mixins into Scope.prototype.\n  The flow is simple. Once we define a mixin, it will be stored in the `$Mixer`,\n  and any time a `ChildScope` prototype is created\n  it will be extended by the `$Mixer`.\n  This concept is good because it keeps our code\n  clean and simple, and easy to extend.\n  So any time we would like to define a new behaviour to our scope,\n  we will just use the `$Mixer` service.\n */\n.service(Mixer, function() {\n  // Used to store method's caller\n  let caller;\n\n  this._mixins = [];\n  // Apply mixins automatically on specified contexts\n  this._autoExtend = [];\n  this._autoConstruct = [];\n\n  // Adds a new mixin\n  this.mixin = (mixin) => {\n    if (!_.isObject(mixin)) {\n      throw Error('argument 1 must be an object');\n    }\n\n    this._mixins = _.union(this._mixins, [mixin]);\n    // Apply mixins to stored contexts\n    this._autoExtend.forEach(context => this._extend(context));\n    this._autoConstruct.forEach(context => this._construct(context));\n    return this;\n  };\n\n  // Removes a mixin. Useful mainly for test purposes\n  this._mixout = (mixin) => {\n    this._mixins = _.without(this._mixins, mixin);\n    return this;\n  };\n\n  // Invoke function mixins with the provided context and arguments\n  this._construct = (context, ...args) => {\n    this._mixins.filter(_.isFunction).forEach((mixin) => {\n      mixin.call(context, ...args);\n    });\n\n    return context;\n  };\n\n  // Extend prototype with the defined mixins\n  this._extend = (obj, options) => {\n    const { pattern, context } = _.defaults({}, options, {\n      pattern: /.*/, // The patterns of the keys which will be filtered\n    });\n\n    const mixins = this._mixins.map((mixin) => {\n      // Filtering the keys by the specified pattern\n      const keys = _.keys(mixin)\n        .filter(k => k.match(pattern))\n        .filter(k => _.isFunction(mixin[k]));\n\n      return keys.reduce((boundMixin, methodName) => {\n        const methodHandler = mixin[methodName];\n\n        // Note that this is not an arrow function so we can conserve the conetxt\n        boundMixin[methodName] = function(...args) {\n          // Storing original caller so we will know who actually called the\n          // method event though it is bound to another context\n          const methodContext = context || this;\n          const recentCaller = caller;\n          caller = this;\n\n          try {\n            return methodHandler.apply(methodContext, args);\n          }\n          finally {\n            // No matter what happens, restore variable to the previous one\n            caller = recentCaller;\n          }\n        };\n\n        return boundMixin;\n      }, {});\n    });\n\n    return _.extend(obj, ...mixins);\n  };\n\n  // Caller property can not be set\n  Object.defineProperty(this, 'caller', {\n    configurable: true,\n    enumerable: true,\n\n    get: () => {\n      return caller;\n    }\n  });\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/mixer.js\n **/","import { name as mixerName, Mixer } from './mixer';\n\nexport const name = 'angular-meteor.scope';\n\nangular.module(name, [\n  mixerName\n])\n\n.run([\n  '$rootScope',\n  Mixer,\n  function($rootScope, $Mixer) {\n    const Scope = $rootScope.constructor;\n    const $new = $rootScope.$new;\n\n    // Apply extensions whether a mixin in defined.\n    // Note that this way mixins which are initialized later\n    // can be applied on rootScope.\n    $Mixer._autoExtend.push(Scope.prototype);\n    $Mixer._autoConstruct.push($rootScope);\n\n    Scope.prototype.$new = function() {\n      const scope = $new.apply(this, arguments);\n      // Apply constructors to newly created scopes\n      return $Mixer._construct(scope);\n    };\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/scope.js\n **/","import { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\n\nexport const name = 'angular-meteor.core';\nexport const Core = '$$Core';\n\nangular.module(name, [\n  utilsName,\n  mixerName\n])\n\n\n/*\n  A mixin which provides us with core Meteor functions.\n */\n.factory(Core, [\n  '$q',\n  utils,\n  Mixer,\n\n  function($q, $$utils, $Mixer) {\n    function $$Core() {}\n\n    // Calls Meteor.autorun() which will be digested after each run and automatically destroyed\n    $$Core.autorun = function(fn, options = {}) {\n      fn = this.$bindToContext($Mixer.caller, fn);\n\n      if (!_.isFunction(fn)) {\n        throw Error('argument 1 must be a function');\n      }\n      if (!_.isObject(options)) {\n        throw Error('argument 2 must be an object');\n      }\n\n      const computation = Tracker.autorun(fn, options);\n      this.$$autoStop(computation);\n      return computation;\n    };\n\n    // Calls Meteor.subscribe() which will be digested after each invokation\n    // and automatically destroyed\n    $$Core.subscribe = function(subName, fn, cb) {\n      fn = this.$bindToContext($Mixer.caller, fn || angular.noop);\n      cb = cb ? this.$bindToContext($Mixer.caller, cb) : angular.noop;\n\n      if (!_.isString(subName)) {\n        throw Error('argument 1 must be a string');\n      }\n      if (!_.isFunction(fn)) {\n        throw Error('argument 2 must be a function');\n      }\n      if (!_.isFunction(cb) && !_.isObject(cb)) {\n        throw Error('argument 3 must be a function or an object');\n      }\n\n      const result = {};\n\n      const computation = this.autorun(() => {\n        let args = fn();\n        if (angular.isUndefined(args)) args = [];\n\n        if (!_.isArray(args)) {\n          throw Error(`reactive function's return value must be an array`);\n        }\n\n        const subscription = Meteor.subscribe(subName, ...args, cb);\n        result.ready = subscription.ready.bind(subscription);\n        result.subscriptionId = subscription.subscriptionId;\n      });\n\n      // Once the computation has been stopped,\n      // any subscriptions made inside will be stopped as well\n      result.stop = computation.stop.bind(computation);\n      return result;\n    };\n\n    // Calls Meteor.call() wrapped by a digestion cycle\n    $$Core.callMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n      return Meteor.call(...args, fn);\n    };\n\n    // Calls Meteor.apply() wrapped by a digestion cycle\n    $$Core.applyMethod = function(...args) {\n      let fn = args.pop();\n      if (_.isFunction(fn)) fn = this.$bindToContext($Mixer.caller, fn);\n      return Meteor.apply(...args, fn);\n    };\n\n    $$Core.$$autoStop = function(stoppable) {\n      this.$on('$destroy', stoppable.stop.bind(stoppable));\n    };\n\n    // Digests scope only if there is no phase at the moment\n    $$Core.$$throttledDigest = function() {\n      const isDigestable = !this.$$destroyed &&\n        !this.$$phase &&\n        !this.$root.$$phase;\n\n      if (isDigestable) this.$digest();\n    };\n\n    // Creates a promise only that the digestion cycle will be called at its fulfillment\n    $$Core.$$defer = function() {\n      const deferred = $q.defer();\n      // Once promise has been fulfilled, digest\n      deferred.promise = deferred.promise.finally(this.$$throttledDigest.bind(this));\n      return deferred;\n    };\n\n    // Binds an object or a function to the provided context and digest it once it is invoked\n    $$Core.$bindToContext = function(context, fn) {\n      return $$utils.bind(fn, context, this.$$throttledDigest.bind(this));\n    };\n\n    return $$Core;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/core.js\n **/","import { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\nimport { name as coreName } from './core';\n\nexport const name = 'angular-meteor.view-model';\nexport const ViewModel = '$$ViewModel';\nexport const reactive = '$reactive';\n\nangular.module(name, [\n  utilsName,\n  mixerName,\n  coreName\n])\n\n/*\n  A mixin which lets us bind a view model into a scope.\n  Note that only a single view model can be bound,\n  otherwise the scope might behave unexpectedly.\n  Mainly used to define the controller as the view model,\n  and very useful when wanting to use Angular's `controllerAs` syntax.\n */\n.factory(ViewModel, [\n  utils,\n  Mixer,\n\n  function($$utils, $Mixer) {\n    function $$ViewModel() {}\n\n    // Gets an object, wraps it with scope functions and returns it\n    $$ViewModel.viewModel = function(vm) {\n      if (!_.isObject(vm)) {\n        throw Error('argument 1 must be an object');\n      }\n\n      // Extend view model with mixin functions\n      $Mixer._extend(vm, {\n        pattern: /^(?!\\$\\$).*$/, // Omitting methods which start with a $$ notation\n        context: this // Binding methods to scope\n      });\n\n      // Apply mixin constructors on scope with view model\n      $Mixer._construct(this, vm);\n      return vm;\n    };\n\n    return $$ViewModel;\n  }\n])\n\n\n/*\n  Illustrates the old API where a view model is created using $reactive service\n */\n.service(reactive, [\n  utils,\n\n  function($$utils) {\n    class Reactive {\n      constructor(vm) {\n        if (!_.isObject(vm)) {\n          throw Error('argument 1 must be an object');\n        }\n\n        _.defer(() => {\n          if (!this._attached) {\n            console.warn('view model was not attached to any scope');\n          }\n        });\n\n        this._vm = vm;\n      }\n\n      attach(scope) {\n        this._attached = true;\n\n        if (!$$utils.isScope(scope)) {\n          throw Error('argument 1 must be a scope');\n        }\n\n        const viewModel = scope.viewModel(this._vm);\n\n        // Similar to the old/Meteor API\n        viewModel.call = viewModel.callMethod;\n        viewModel.apply = viewModel.applyMethod;\n\n        return viewModel;\n      }\n    }\n\n    return (vm) => new Reactive(vm);\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/view-model.js\n **/","import { name as utilsName, utils } from './utils';\nimport { name as mixerName, Mixer } from './mixer';\nimport { name as coreName } from './core';\nimport { name as viewModelName } from './view-model';\n\nexport const name = 'angular-meteor.reactive';\nexport const Reactive = '$$Reactive';\n\nangular.module(name, [\n  utilsName,\n  mixerName,\n  coreName,\n  viewModelName\n])\n\n\n/*\n  A mixin which enhance our reactive abilities by providing methods\n  that are capable of updating our scope reactively.\n */\n.factory(Reactive, [\n  '$parse',\n  utils,\n  Mixer,\n\n  function($parse, $$utils, $Mixer) {\n    function $$Reactive(vm = this) {\n      // Helps us track changes made in the view model\n      vm.$$dependencies = {};\n    }\n\n    // Gets an object containing functions and define their results as reactive properties.\n    // Once a return value has been changed the property will be reset.\n    $$Reactive.helpers = function(vm, props) {\n      if ($$utils.isViewModel(vm)) {\n        if (!_.isObject(props)) {\n          throw Error('argument 2 must be an object');\n        }\n      }\n      else {\n        props = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isObject(props)) {\n          throw Error('argument 1 must be an object');\n        }\n      }\n\n      _.each(props, (v, k) => {\n        if (!_.isFunction(v)) {\n          throw Error(`helper '${k}' must be a function`);\n        }\n      });\n\n      _.each(props, (v, k) => {\n        if (!vm.$$dependencies[k]) {\n        // Registers a new dependency to the specified helper\n          vm.$$dependencies[k] = new Tracker.Dependency();\n        }\n\n        this.$$setFnHelper(vm, k, v);\n      });\n    };\n\n    // Gets a model reactively\n    $$Reactive.getReactively = function(vm, k, isDeep) {\n      if ($$utils.isViewModel(vm)) {\n        if (angular.isUndefined(isDeep)) isDeep = false;\n\n        if (!_.isString(k)) {\n          throw Error('argument 2 must be a string');\n        }\n        if (!_.isBoolean(isDeep)) {\n          throw Error('argument 3 must be a boolean');\n        }\n      }\n      else {\n        isDeep = angular.isDefined(k) ? k : false;\n        k = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isString(k)) {\n          throw Error('argument 1 must be a string');\n        }\n        if (!_.isBoolean(isDeep)) {\n          throw Error('argument 2 must be a boolean');\n        }\n      }\n\n      return this.$$reactivateEntity(vm, k, this.$watch, isDeep);\n    };\n\n    // Gets a collection reactively\n    $$Reactive.getCollectionReactively = function(vm, k) {\n      if ($$utils.isViewModel(vm)) {\n        if (!_.isString(k)) {\n          throw Error('argument 2 must be a string');\n        }\n      }\n      else {\n        k = vm;\n        vm = $Mixer.caller;\n\n        if (!_.isString(k)) {\n          throw Error('argument 1 must be a string');\n        }\n      }\n\n      return this.$$reactivateEntity(vm, k, this.$watchCollection);\n    };\n\n    // Gets an entity reactively, and once it has been changed the computation will be recomputed\n    $$Reactive.$$reactivateEntity = function(vm, k, watcher, ...watcherArgs) {\n      if (!vm.$$dependencies[k]) {\n        vm.$$dependencies[k] = new Tracker.Dependency();\n        this.$$watchEntity(vm, k, watcher, ...watcherArgs);\n      }\n\n      vm.$$dependencies[k].depend();\n      return $parse(k)(vm);\n    };\n\n    // Watches for changes in the view model, and if so will notify a change\n    $$Reactive.$$watchEntity = function(vm, k, watcher, ...watcherArgs) {\n      // Gets a deep property from the caller\n      const getVal = _.partial($parse(k), vm);\n      const initialVal = getVal();\n\n      // Watches for changes in the view model\n      watcher.call(this, getVal, (val, oldVal) => {\n        const hasChanged =\n          val !== initialVal ||\n          val !== oldVal;\n\n        // Notify if a change has been detected\n        if (hasChanged) this.$$changed(vm, k);\n      }, ...watcherArgs);\n    };\n\n    // Invokes a function and sets the return value as a property\n    $$Reactive.$$setFnHelper = function(vm, k, fn) {\n      this.autorun((computation) => {\n        // Invokes the reactive functon\n        const model = fn.apply(vm);\n\n        // Ignore notifications made by the following handler\n        Tracker.nonreactive(() => {\n          // If a cursor, observe its changes and update acoordingly\n          if ($$utils.isCursor(model)) {\n            const observation = this.$$handleCursor(vm, k, model);\n\n            computation.onInvalidate(() => {\n              observation.stop();\n              vm[k].splice(0);\n            });\n          } else {\n            this.$$handleNonCursor(vm, k, model);\n          }\n\n          // Notify change and update the view model\n          this.$$changed(vm, k);\n        });\n      });\n    };\n\n    // Sets a value helper as a setter and a getter which will notify computations once used\n    $$Reactive.$$setValHelper = function(vm, k, v, watch = true) {\n      // If set, reactives property\n      if (watch) {\n        const isDeep = _.isObject(v);\n        this.getReactively(vm, k, isDeep);\n      }\n\n      Object.defineProperty(vm, k, {\n        configurable: true,\n        enumerable: true,\n\n        get: () => {\n          return v;\n        },\n        set: (newVal) => {\n          v = newVal;\n          this.$$changed(vm, k);\n        }\n      });\n    };\n\n    // Fetching a cursor and updates properties once the result set has been changed\n    $$Reactive.$$handleCursor = function(vm, k, cursor) {\n      // If not defined set it\n      if (angular.isUndefined(vm[k])) {\n        this.$$setValHelper(vm, k, cursor.fetch(), false);\n      }\n      // If defined update it\n      else {\n        const diff = jsondiffpatch.diff(vm[k], cursor.fetch());\n        jsondiffpatch.patch(vm[k], diff);\n      }\n\n      // Observe changes made in the result set\n      const observation = cursor.observe({\n        addedAt: (doc, atIndex) => {\n          if (!observation) return;\n          vm[k].splice(atIndex, 0, doc);\n          this.$$changed(vm, k);\n        },\n        changedAt: (doc, oldDoc, atIndex) => {\n          const diff = jsondiffpatch.diff(vm[k][atIndex], doc);\n          jsondiffpatch.patch(vm[k][atIndex], diff);\n          this.$$changed(vm, k);\n        },\n        movedTo: (doc, fromIndex, toIndex) => {\n          vm[k].splice(fromIndex, 1);\n          vm[k].splice(toIndex, 0, doc);\n          this.$$changed(vm, k);\n        },\n        removedAt: (oldDoc, atIndex) => {\n          vm[k].splice(atIndex, 1);\n          this.$$changed(vm, k);\n        }\n      });\n\n      return observation;\n    };\n\n    $$Reactive.$$handleNonCursor = function(vm, k, data) {\n      let v = vm[k];\n\n      if (angular.isDefined(v)) {\n        delete vm[k];\n        v = null;\n      }\n\n      if (angular.isUndefined(v)) {\n        this.$$setValHelper(vm, k, data);\n      }\n      // Update property if the new value is from the same type\n      else if ($$utils.areSiblings(v, data)) {\n        const diff = jsondiffpatch.diff(v, data);\n        jsondiffpatch.patch(v, diff);\n        this.$$changed(vm, k);\n      } else {\n        vm[k] = data;\n      }\n    };\n\n    // Notifies dependency in view model\n    $$Reactive.$$depend = function(vm, k) {\n      vm.$$dependencies[k].depend();\n    };\n\n    // Notifies change in view model\n    $$Reactive.$$changed = function(vm, k) {\n      this.$$throttledDigest();\n      vm.$$dependencies[k].changed();\n    };\n\n    return $$Reactive;\n  }\n]);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/reactive.js\n **/","export const name = 'angular-templates';\n\ntry {\n  angular.module(name);\n} catch (e) {\n  angular.module(name, []);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/modules/templates.js\n **/"],"sourceRoot":""}